diff --git a/build/AV.js.map b/build/AV.js.map
index 2475e81565498da69990f935704c5d6026505719..6a707284f091ae6aa8ce706a295706447952040a 100644
--- a/build/AV.js.map
+++ b/build/AV.js.map
@@ -1 +1 @@
-{"version":3,"file":"AV.js","sourceRoot":"","sources":["../src/AV.ts"],"names":[],"mappings":"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","sourcesContent":["import { Asset } from 'expo-asset';\nimport { Platform } from 'expo-modules-core';\n\nimport {\n  AVPlaybackSource,\n  AVPlaybackNativeSource,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  PitchCorrectionQuality,\n  AVPlaybackTolerance,\n} from './AV.types';\n\n// TODO add:\n//  disableFocusOnAndroid\n//  audio routes (at least did become noisy on android)\n//  pan\n//  pitch\n//  API to explicitly request audio focus / session\n//  API to select stream type on Android\n//  subtitles API\n\n/**\n * @hidden\n */\nexport const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS: number = 500;\n\n// @needsAudit\n/**\n * The default initial `AVPlaybackStatusToSet` of all `Audio.Sound` objects and `Video` components is as follows:\n *\n * ```javascript\n * {\n *   progressUpdateIntervalMillis: 500,\n *   positionMillis: 0,\n *   shouldPlay: false,\n *   rate: 1.0,\n *   shouldCorrectPitch: false,\n *   volume: 1.0,\n *   isMuted: false,\n *   isLooping: false,\n * }\n * ```\n *\n * This default initial status can be overwritten by setting the optional `initialStatus` in `loadAsync()` or `Audio.Sound.createAsync()`.\n */\nexport const _DEFAULT_INITIAL_PLAYBACK_STATUS: AVPlaybackStatusToSet = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  audioPan: 0,\n  isMuted: false,\n  isLooping: false,\n};\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getNativeSourceFromSource(\n  source?: AVPlaybackSource | null\n): AVPlaybackNativeSource | null {\n  let uri: string | null = null;\n  let overridingExtension: string | null = null;\n  let headers: AVPlaybackNativeSource['headers'];\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension,\n      headers,\n    };\n  }\n\n  const asset: Asset | null = _getAssetFromPlaybackSource(source);\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (\n    source != null &&\n    typeof source !== 'number' &&\n    'uri' in source &&\n    typeof source.uri === 'string'\n  ) {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'overrideFileExtensionAndroid' in source &&\n    typeof source.overrideFileExtensionAndroid === 'string'\n  ) {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'headers' in source &&\n    typeof source.headers === 'object'\n  ) {\n    headers = source.headers;\n  }\n  return { uri, overridingExtension, headers };\n}\n\nfunction _getAssetFromPlaybackSource(source?: AVPlaybackSource | null): Asset | null {\n  if (source == null) {\n    return null;\n  }\n\n  let asset: Asset | null = null;\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n  return asset;\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function assertStatusValuesInBounds(status: AVPlaybackStatusToSet): void {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n  if (typeof status.audioPan === 'number' && (status.audioPan < -1 || status.audioPan > 1)) {\n    throw new RangeError('Pan value must be between -1.0 and 1.0');\n  }\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport async function getNativeSourceAndFullInitialStatusForLoadAsync(\n  source: AVPlaybackSource | null,\n  initialStatus: AVPlaybackStatusToSet | null,\n  downloadFirst: boolean\n): Promise<{\n  nativeSource: AVPlaybackNativeSource;\n  fullInitialStatus: AVPlaybackStatusToSet;\n}> {\n  // Get the full initial status\n  const fullInitialStatus: AVPlaybackStatusToSet =\n    initialStatus == null\n      ? _DEFAULT_INITIAL_PLAYBACK_STATUS\n      : {\n          ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n          ...initialStatus,\n        };\n  assertStatusValuesInBounds(fullInitialStatus);\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      nativeSource: {\n        uri: source,\n        overridingExtension: null,\n      },\n      fullInitialStatus,\n    };\n  }\n\n  // Download first if necessary.\n  const asset = _getAssetFromPlaybackSource(source);\n  if (downloadFirst && asset) {\n    // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n    await asset.downloadAsync();\n  }\n\n  // Get the native source\n  const nativeSource: AVPlaybackNativeSource | null = getNativeSourceFromSource(source);\n\n  if (nativeSource === null) {\n    throw new Error(`Cannot load an AV asset from a null playback source`);\n  }\n\n  // If asset has been downloaded use the localUri\n  if (asset && asset.localUri) {\n    nativeSource.uri = asset.localUri;\n  }\n\n  return { nativeSource, fullInitialStatus };\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getUnloadedStatus(error: string | null = null): AVPlaybackStatus {\n  return {\n    isLoaded: false,\n    ...(error ? { error } : null),\n  };\n}\n\n// @needsAudit\nexport interface AV {\n  /**\n   * Sets a new `AVPlaybackStatusToSet` on the `playbackObject`. This method can only be called if the media has been loaded.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed. See below for details on `AVPlaybackStatus`.\n   */\n  setStatusAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * Gets the `AVPlaybackStatus` of the `playbackObject`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject`.\n   */\n  getStatusAsync(): Promise<AVPlaybackStatus>;\n}\n\n// @needsAudit\n/**\n * On the `playbackObject` reference, the following API is provided.\n */\nexport interface Playback extends AV {\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   */\n  playAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Loads the media from `source` into memory and prepares it for playing. This must be called before calling `setStatusAsync()`\n   * or any of the convenience set status methods. This method can only be called if the `playbackObject` is in an unloaded state.\n   * @param source The source of the media.\n   * @param initialStatus The initial intended `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. For more information see the details on `AVPlaybackStatusToSet` type\n   * and the default initial playback status.\n   * @param downloadAsync If set to `true`, the system will attempt to download the resource to the device before loading.\n   * This value defaults to `true`. Note that at the moment, this will only work for `source`s of the form `require('path/to/file')` or `Asset` objects.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is loaded, or rejects if loading failed.\n   * The `Promise` will also reject if the `playbackObject` was already loaded. See below for details on `AVPlaybackStatus`.\n   */\n  loadAsync(\n    source: AVPlaybackSource,\n    initialStatus?: AVPlaybackStatusToSet,\n    downloadAsync?: boolean\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * Unloads the media from memory. `loadAsync()` must be called again in order to be able to play the media.\n   * > This cleanup function will be automatically called in the `Video` component's `componentWillUnmount`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is unloaded, or rejects if unloading failed.\n   */\n  unloadAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true, positionMillis, seekMillisToleranceAfter: tolerances.seekMillisToleranceAfter, seekMillisToleranceBefore: tolerances.seekMillisToleranceBefore })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would)).\n   */\n  playFromPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false })`.\n   */\n  pauseAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false, positionMillis: 0 })`.\n   */\n  stopAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Replays the playback item. When using `playFromPositionAsync(0)` the item is seeked to the position at `0 ms`.\n   * On iOS this method uses internal implementation of the player and is able to play the item from the beginning immediately.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * `positionMillis` and `shouldPlay` properties will be overridden with respectively `0` and `true`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed.\n   */\n  replayAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ positionMillis })`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would)).\n   */\n  setPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ rate, shouldCorrectPitch, pitchCorrectionQuality })`.\n   * @param rate The desired playback rate of the media. This value must be between `0.0` and `32.0`. Only available on Android API version 23 and later and iOS.\n   * @param shouldCorrectPitch A boolean describing if we should correct the pitch for a changed rate. If set to `true`, the pitch of the audio will be corrected\n   * (so a rate different than `1.0` will timestretch the audio).\n   * @param pitchCorrectionQuality iOS time pitch algorithm setting, defaults to `Audio.PitchCorrectionQuality.Medium`.\n   * Using `Audio.PitchCorrectionQuality.Low` may cause automatic playback rate changes on iOS >= 17, as AVAudioTimePitchAlgorithmLowQualityZeroLatency is deprecated.\n   */\n  setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ volume, audioPan })`.\n   * Note: `audioPan` is currently only supported on Android using `androidImplementation: 'MediaPlayer'`\n   * @param volume A number between `0.0` (silence) and `1.0` (maximum volume).\n   * @param audioPan A number between `-1.0` (full left) and `1.0` (full right).\n   */\n  setVolumeAsync(volume: number, audioPan?: number): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isMuted })`.\n   * @param isMuted A boolean describing if the audio of this media should be muted.\n   */\n  setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isLooping })`.\n   * @param isLooping A boolean describing if the media should play once (`false`) or loop indefinitely (`true`).\n   */\n  setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ progressUpdateIntervalMillis })`.\n   * @param progressUpdateIntervalMillis The new minimum interval in milliseconds between calls of `onPlaybackStatusUpdate`.\n   * See `setOnPlaybackStatusUpdate()` for details.\n   */\n  setProgressUpdateIntervalAsync(progressUpdateIntervalMillis: number): Promise<AVPlaybackStatus>;\n}\n\n/**\n * @hidden\n * A mixin that defines common playback methods for A/V classes, so they implement the `Playback`\n * interface.\n */\nexport const PlaybackMixin = {\n  async playAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: true });\n  },\n\n  async playFromPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      shouldPlay: true,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async pauseAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: false });\n  },\n\n  async stopAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ positionMillis: 0, shouldPlay: false });\n  },\n\n  async setPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean = false,\n    pitchCorrectionQuality: PitchCorrectionQuality = PitchCorrectionQuality.Medium\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      rate,\n      shouldCorrectPitch,\n      pitchCorrectionQuality,\n    });\n  },\n\n  async setVolumeAsync(volume: number, audioPan?: number): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ volume, audioPan });\n  },\n\n  async setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isMuted });\n  },\n\n  async setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isLooping });\n  },\n\n  async setProgressUpdateIntervalAsync(\n    progressUpdateIntervalMillis: number\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ progressUpdateIntervalMillis });\n  },\n};\n\nexport * from './AV.types';\n"]}
\ No newline at end of file
+{"version":3,"file":"AV.js","sourceRoot":"","sources":["../src/AV.ts"],"names":[],"mappings":"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","sourcesContent":["import { Asset } from 'expo-asset';\nimport { Platform } from 'expo-modules-core';\n\nimport {\n  AVPlaybackSource,\n  AVPlaybackNativeSource,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  PitchCorrectionQuality,\n  AVPlaybackTolerance,\n} from './AV.types';\n\n// TODO add:\n//  disableFocusOnAndroid\n//  audio routes (at least did become noisy on android)\n//  pan\n//  pitch\n//  API to explicitly request audio focus / session\n//  API to select stream type on Android\n//  subtitles API\n\n/**\n * @hidden\n */\nexport const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS: number = 500;\n\n// @needsAudit\n/**\n * The default initial `AVPlaybackStatusToSet` of all `Audio.Sound` objects and `Video` components is as follows:\n *\n * ```javascript\n * {\n *   progressUpdateIntervalMillis: 500,\n *   positionMillis: 0,\n *   shouldPlay: false,\n *   rate: 1.0,\n *   shouldCorrectPitch: false,\n *   volume: 1.0,\n *   isMuted: false,\n *   isLooping: false,\n * }\n * ```\n *\n * This default initial status can be overwritten by setting the optional `initialStatus` in `loadAsync()` or `Audio.Sound.createAsync()`.\n */\nexport const _DEFAULT_INITIAL_PLAYBACK_STATUS: AVPlaybackStatusToSet = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  audioPan: 0,\n  isMuted: false,\n  isLooping: false,\n};\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getNativeSourceFromSource(\n  source?: AVPlaybackSource | null\n): AVPlaybackNativeSource | null {\n  let uri: string | null = null;\n  let overridingExtension: string | null = null;\n  let headers: AVPlaybackNativeSource['headers'];\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension,\n      headers,\n    };\n  }\n\n  const asset: Asset | null = _getAssetFromPlaybackSource(source);\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (\n    source != null &&\n    typeof source !== 'number' &&\n    'uri' in source &&\n    typeof source.uri === 'string'\n  ) {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'overrideFileExtensionAndroid' in source &&\n    typeof source.overrideFileExtensionAndroid === 'string'\n  ) {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'headers' in source &&\n    typeof source.headers === 'object'\n  ) {\n    headers = source.headers;\n  }\n  return { uri, overridingExtension, headers };\n}\n\nfunction _getAssetFromPlaybackSource(source?: AVPlaybackSource | null): Asset | null {\n  if (source == null) {\n    return null;\n  }\n\n  let asset: Asset | null = null;\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n  return asset;\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function assertStatusValuesInBounds(status: AVPlaybackStatusToSet): void {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n  if (typeof status.audioPan === 'number' && (status.audioPan < -1 || status.audioPan > 1)) {\n    throw new RangeError('Pan value must be between -1.0 and 1.0');\n  }\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport async function getNativeSourceAndFullInitialStatusForLoadAsync(\n  source: AVPlaybackSource | null,\n  initialStatus: AVPlaybackStatusToSet | null,\n  downloadFirst: boolean\n): Promise<{\n  nativeSource: AVPlaybackNativeSource;\n  fullInitialStatus: AVPlaybackStatusToSet;\n}> {\n  // Get the full initial status\n  const fullInitialStatus: AVPlaybackStatusToSet =\n    initialStatus == null\n      ? _DEFAULT_INITIAL_PLAYBACK_STATUS\n      : {\n          ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n          ...initialStatus,\n        };\n  assertStatusValuesInBounds(fullInitialStatus);\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      nativeSource: {\n        uri: source,\n        overridingExtension: null,\n      },\n      fullInitialStatus,\n    };\n  }\n\n  // Download first if necessary.\n  const asset = _getAssetFromPlaybackSource(source);\n  if (downloadFirst && asset) {\n    // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n    await asset.downloadAsync();\n  }\n\n  // Get the native source\n  const nativeSource: AVPlaybackNativeSource | null = getNativeSourceFromSource(source);\n\n  if (nativeSource === null) {\n    throw new Error(`Cannot load an AV asset from a null playback source`);\n  }\n\n  // If asset has been downloaded use the localUri\n  if (asset && asset.localUri) {\n    nativeSource.uri = asset.localUri;\n  }\n\n  return { nativeSource, fullInitialStatus };\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getUnloadedStatus(error: string | null = null): AVPlaybackStatus {\n  return {\n    isLoaded: false,\n    ...(error ? { error } : null),\n  };\n}\n\n// @needsAudit\nexport interface AV {\n  /**\n   * Sets a new `AVPlaybackStatusToSet` on the `playbackObject`. This method can only be called if the media has been loaded.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed. See below for details on `AVPlaybackStatus`.\n   */\n  setStatusAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * Gets the `AVPlaybackStatus` of the `playbackObject`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject`.\n   */\n  getStatusAsync(): Promise<AVPlaybackStatus>;\n}\n\n// @needsAudit\n/**\n * On the `playbackObject` reference, the following API is provided.\n */\nexport interface Playback extends AV {\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   */\n  playAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Loads the media from `source` into memory and prepares it for playing. This must be called before calling `setStatusAsync()`\n   * or any of the convenience set status methods. This method can only be called if the `playbackObject` is in an unloaded state.\n   * @param source The source of the media.\n   * @param initialStatus The initial intended `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. For more information see the details on `AVPlaybackStatusToSet` type\n   * and the default initial playback status.\n   * @param downloadAsync If set to `true`, the system will attempt to download the resource to the device before loading.\n   * This value defaults to `true`. Note that at the moment, this will only work for `source`s of the form `require('path/to/file')` or `Asset` objects.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is loaded, or rejects if loading failed.\n   * The `Promise` will also reject if the `playbackObject` was already loaded. See below for details on `AVPlaybackStatus`.\n   */\n  loadAsync(\n    source: AVPlaybackSource,\n    initialStatus?: AVPlaybackStatusToSet,\n    downloadAsync?: boolean\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * Unloads the media from memory. `loadAsync()` must be called again in order to be able to play the media.\n   * > This cleanup function will be automatically called in the `Video` component's `componentWillUnmount`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is unloaded, or rejects if unloading failed.\n   */\n  unloadAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true, positionMillis, seekMillisToleranceAfter: tolerances.seekMillisToleranceAfter, seekMillisToleranceBefore: tolerances.seekMillisToleranceBefore })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would)).\n   */\n  playFromPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false })`.\n   */\n  pauseAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false, positionMillis: 0 })`.\n   */\n  stopAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Replays the playback item. When using `playFromPositionAsync(0)` the item is seeked to the position at `0 ms`.\n   * On iOS this method uses internal implementation of the player and is able to play the item from the beginning immediately.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * `positionMillis` and `shouldPlay` properties will be overridden with respectively `0` and `true`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed.\n   */\n  replayAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ positionMillis })`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would)).\n   */\n  setPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ rate, shouldCorrectPitch, pitchCorrectionQuality })`.\n   * @param rate The desired playback rate of the media. This value must be between `0.0` and `32.0`. Only available on Android API version 23 and later and iOS.\n   * @param shouldCorrectPitch A boolean describing if we should correct the pitch for a changed rate. If set to `true`, the pitch of the audio will be corrected\n   * (so a rate different than `1.0` will timestretch the audio).\n   * @param pitchCorrectionQuality iOS time pitch algorithm setting, defaults to `Audio.PitchCorrectionQuality.Medium`.\n   * Using `Audio.PitchCorrectionQuality.Low` may cause automatic playback rate changes on iOS >= 17, as AVAudioTimePitchAlgorithmLowQualityZeroLatency is deprecated.\n   */\n  setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ volume, audioPan })`.\n   * Note: `audioPan` is currently only supported on Android using `androidImplementation: 'MediaPlayer'`\n   * @param volume A number between `0.0` (silence) and `1.0` (maximum volume).\n   * @param audioPan A number between `-1.0` (full left) and `1.0` (full right).\n   */\n  setVolumeAsync(volume: number, audioPan?: number): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isMuted })`.\n   * @param isMuted A boolean describing if the audio of this media should be muted.\n   */\n  setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isLooping })`.\n   * @param isLooping A boolean describing if the media should play once (`false`) or loop indefinitely (`true`).\n   */\n  setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ progressUpdateIntervalMillis })`.\n   * @param progressUpdateIntervalMillis The new minimum interval in milliseconds between calls of `onPlaybackStatusUpdate`.\n   * See `setOnPlaybackStatusUpdate()` for details.\n   */\n  setProgressUpdateIntervalAsync(progressUpdateIntervalMillis: number): Promise<AVPlaybackStatus>;\n}\n\n/**\n * @hidden\n * A mixin that defines common playback methods for A/V classes, so they implement the `Playback`\n * interface.\n */\nexport const PlaybackMixin = {\n  async playAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: true });\n  },\n\n  async playFromPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      shouldPlay: true,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async pauseAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: false });\n  },\n\n  async stopAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ positionMillis: 0, shouldPlay: false });\n  },\n\n  async setPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean = false,\n    pitchCorrectionQuality: PitchCorrectionQuality = PitchCorrectionQuality.Medium\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      rate,\n      shouldCorrectPitch,\n      pitchCorrectionQuality,\n    });\n  },\n\n  async setVolumeAsync(volume: number, audioPan?: number): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ volume, audioPan });\n  },\n\n  async setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isMuted });\n  },\n\n  async setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isLooping });\n  },\n\n  async setProgressUpdateIntervalAsync(\n    progressUpdateIntervalMillis: number\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ progressUpdateIntervalMillis });\n  },\n};\n\nexport * from './AV.types';\n"]}
\ No newline at end of file
diff --git a/build/Audio/AudioAvailability.js.map b/build/Audio/AudioAvailability.js.map
index 58ec4c2b7b76cba7f6a88882caf361f6ccf10e04..3b60c82c1ec4c42e5359ec7b9aa60d84e754511d 100644
--- a/build/Audio/AudioAvailability.js.map
+++ b/build/Audio/AudioAvailability.js.map
@@ -1 +1 @@
-{"version":3,"file":"AudioAvailability.js","sourceRoot":"","sources":["../../src/Audio/AudioAvailability.ts"],"names":[],"mappings":"AAAA,OAAO,UAAU,MAAM,eAAe,CAAC;AAEvC,IAAI,QAAQ,GAAG,IAAI,CAAC;AAEpB,MAAM,UAAU,cAAc;IAC5B,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED,MAAM,UAAU,sBAAsB;IACpC,IAAI,CAAC,QAAQ,EAAE;QACb,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;KAC5E;AACH,CAAC;AAED,cAAc;AACd;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,iBAAiB,CAAC,KAAc;IACpD,QAAQ,GAAG,KAAK,CAAC;IACjB,MAAM,UAAU,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;IAC1C,6FAA6F;IAC7F,yFAAyF;IACzF,gGAAgG;IAChG,oDAAoD;AACtD,CAAC","sourcesContent":["import ExponentAV from '../ExponentAV';\n\nlet _enabled = true;\n\nexport function isAudioEnabled(): boolean {\n  return _enabled;\n}\n\nexport function throwIfAudioIsDisabled(): void {\n  if (!_enabled) {\n    throw new Error('Cannot complete operation because audio is not enabled.');\n  }\n}\n\n// @needsAudit\n/**\n * Audio is enabled by default, but if you want to write your own Audio API in a bare workflow app, you might want to disable the Audio API.\n * @param value `true` enables Audio, and `false` disables it.\n * @return A `Promise` that will reject if audio playback could not be enabled for the device.\n */\nexport async function setIsEnabledAsync(value: boolean): Promise<void> {\n  _enabled = value;\n  await ExponentAV.setAudioIsEnabled(value);\n  // TODO : We immediately pause all players when disabled, but we do not resume all shouldPlay\n  // players when enabled. Perhaps for completeness we should allow this; the design of the\n  // enabling API is for people to enable / disable this audio library, but I think that it should\n  // intuitively also double as a global pause/resume.\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"AudioAvailability.js","sourceRoot":"","sources":["../../src/Audio/AudioAvailability.ts"],"names":[],"mappings":"AAAA,OAAO,UAAU,MAAM,eAAe,CAAC;AAEvC,IAAI,QAAQ,GAAG,IAAI,CAAC;AAEpB,MAAM,UAAU,cAAc;IAC5B,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED,MAAM,UAAU,sBAAsB;IACpC,IAAI,CAAC,QAAQ,EAAE,CAAC;QACd,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;IAC7E,CAAC;AACH,CAAC;AAED,cAAc;AACd;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,iBAAiB,CAAC,KAAc;IACpD,QAAQ,GAAG,KAAK,CAAC;IACjB,MAAM,UAAU,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;IAC1C,6FAA6F;IAC7F,yFAAyF;IACzF,gGAAgG;IAChG,oDAAoD;AACtD,CAAC","sourcesContent":["import ExponentAV from '../ExponentAV';\n\nlet _enabled = true;\n\nexport function isAudioEnabled(): boolean {\n  return _enabled;\n}\n\nexport function throwIfAudioIsDisabled(): void {\n  if (!_enabled) {\n    throw new Error('Cannot complete operation because audio is not enabled.');\n  }\n}\n\n// @needsAudit\n/**\n * Audio is enabled by default, but if you want to write your own Audio API in a bare workflow app, you might want to disable the Audio API.\n * @param value `true` enables Audio, and `false` disables it.\n * @return A `Promise` that will reject if audio playback could not be enabled for the device.\n */\nexport async function setIsEnabledAsync(value: boolean): Promise<void> {\n  _enabled = value;\n  await ExponentAV.setAudioIsEnabled(value);\n  // TODO : We immediately pause all players when disabled, but we do not resume all shouldPlay\n  // players when enabled. Perhaps for completeness we should allow this; the design of the\n  // enabling API is for people to enable / disable this audio library, but I think that it should\n  // intuitively also double as a global pause/resume.\n}\n"]}
\ No newline at end of file
diff --git a/build/Audio/Recording.d.ts b/build/Audio/Recording.d.ts
index b44185872bc97ef437e3251ec7c1d7e8b8b38ce2..0450055c7130394ce0695c0b15678220f5be7913 100644
--- a/build/Audio/Recording.d.ts
+++ b/build/Audio/Recording.d.ts
@@ -21,7 +21,7 @@ export declare function requestPermissionsAsync(): Promise<PermissionResponse>;
  * const [permissionResponse, requestPermission] = Audio.usePermissions();
  * ```
  */
-export declare const usePermissions: (options?: PermissionHookOptions<object> | undefined) => [PermissionResponse | null, () => Promise<PermissionResponse>, () => Promise<PermissionResponse>];
+export declare const usePermissions: any;
 /**
  * This class represents an audio recording. After creating an instance of this class, `prepareToRecordAsync`
  * must be called in order to record audio. Once recording is finished, call `stopAndUnloadAsync`. Note that
diff --git a/build/Audio/Recording.d.ts.map b/build/Audio/Recording.d.ts.map
index e6b080a5e32f86e10510afd6cc5056b9102678ab..c5edb2cb34d1fc969cc666fcb95751ce9013ca46 100644
--- a/build/Audio/Recording.d.ts.map
+++ b/build/Audio/Recording.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"Recording.d.ts","sourceRoot":"","sources":["../../src/Audio/Recording.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"Recording.d.ts","sourceRoot":"","sources":["../../src/Audio/Recording.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/build/Audio/Recording.js b/build/Audio/Recording.js
index 9b16fcd7082a4a0c09ad2f4196ce7ffd31abab74..565f7f2a3027dd275e564c45dcaf3bdd2833d604 100644
--- a/build/Audio/Recording.js
+++ b/build/Audio/Recording.js
@@ -1,4 +1,4 @@
-import { PermissionStatus, createPermissionHook, EventEmitter, Platform, } from 'expo-modules-core';
+import { PermissionResponse, PermissionStatus, PermissionHookOptions, createPermissionHook, EventEmitter, Platform, } from 'expo-modules-core';
 import { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';
 import { RecordingOptionsPresets } from './RecordingConstants';
 import { Sound } from './Sound';
@@ -390,7 +390,7 @@ export class Recording {
         { uri: this._uri }, initialStatus, onPlaybackStatusUpdate, false);
     }
 }
-export { PermissionStatus };
+export { PermissionResponse, PermissionStatus, PermissionHookOptions };
 export * from './RecordingConstants';
 export * from './Recording.types';
 //# sourceMappingURL=Recording.js.map
\ No newline at end of file
diff --git a/build/Audio/Recording.js.map b/build/Audio/Recording.js.map
index c6099f979fe823dfa4814fdd33261246f1f006b7..c5be5a54aa5b8cd1025cfc0feb66d9a1e990039d 100644
--- a/build/Audio/Recording.js.map
+++ b/build/Audio/Recording.js.map
@@ -1 +1 @@
-{"version":3,"file":"Recording.js","sourceRoot":"","sources":["../../src/Audio/Recording.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  createPermissionHook,\n  EventEmitter,\n  Subscription,\n  Platform,\n} from 'expo-modules-core';\n\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport {\n  RecordingInput,\n  RecordingObject,\n  RecordingOptions,\n  RecordingStatus,\n} from './Recording.types';\nimport { RecordingOptionsPresets } from './RecordingConstants';\nimport { Sound, SoundObject } from './Sound';\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n} from '../AV';\nimport ExponentAV from '../ExponentAV';\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\n/**\n * Checks user's permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.getPermissionsAsync();\n}\n\n/**\n * Asks the user to grant permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.requestPermissionsAsync();\n}\n\n/**\n * Check or request permissions to record audio.\n * This uses both `requestPermissionAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [permissionResponse, requestPermission] = Audio.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * This class represents an audio recording. After creating an instance of this class, `prepareToRecordAsync`\n * must be called in order to record audio. Once recording is finished, call `stopAndUnloadAsync`. Note that\n * only one recorder is allowed to exist in the state between `prepareToRecordAsync` and `stopAndUnloadAsync`\n * at any given time.\n *\n * Note that your experience must request audio recording permissions in order for recording to function.\n * See the [`Permissions` module](/guides/permissions) for more details.\n *\n * Additionally, audio recording is [not supported in the iOS Simulator](/workflow/ios-simulator/#limitations).\n *\n * @example\n * ```ts\n * const recording = new Audio.Recording();\n * try {\n *   await recording.prepareToRecordAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY);\n *   await recording.startAsync();\n *   // You are now recording!\n * } catch (error) {\n *   // An error occurred!\n * }\n * ```\n *\n * @return A newly constructed instance of `Audio.Recording`.\n */\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus?: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    this._finalDurationMillis = finalStatus?.durationMillis ?? 0;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      ) as any;\n      try {\n        await this.getStatusAsync();\n      } catch {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  /**\n   * Creates and starts a recording using the given options, with optional `onRecordingStatusUpdate` and `progressUpdateIntervalMillis`.\n   *\n   * ```ts\n   * const { recording, status } = await Audio.Recording.createAsync(\n   *   options,\n   *   onRecordingStatusUpdate,\n   *   progressUpdateIntervalMillis\n   * );\n   *\n   * // Which is equivalent to the following:\n   * const recording = new Audio.Recording();\n   * await recording.prepareToRecordAsync(options);\n   * recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n   * await recording.startAsync();\n   * ```\n   *\n   * @param options Options for the recording, including sample rate, bitrate, channels, format, encoder, and extension. If no options are passed to,\n   * the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`. See below for details on `RecordingOptions`.\n   * @param onRecordingStatusUpdate A function taking a single parameter `status` (a dictionary, described in `getStatusAsync`).\n   * @param progressUpdateIntervalMillis The interval between calls of `onRecordingStatusUpdate`. This value defaults to 500 milliseconds.\n   *\n   * @example\n   * ```ts\n   * try {\n   *   const { recording: recordingObject, status } = await Audio.Recording.createAsync(\n   *     Audio.RecordingOptionsPresets.HIGH_QUALITY\n   *   );\n   *   // You are now recording!\n   * } catch (error) {\n   *   // An error occurred!\n   * }\n   * ```\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the following dictionary if creation succeeded.\n   */\n  static createAsync = async (\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY,\n    onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null,\n    progressUpdateIntervalMillis: number | null = null\n  ): Promise<RecordingObject> => {\n    const recording: Recording = new Recording();\n    if (progressUpdateIntervalMillis) {\n      recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    }\n    recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n    await recording.prepareToRecordAsync({\n      ...options,\n      keepAudioActiveHint: true,\n    });\n    try {\n      const status = await recording.startAsync();\n      return { recording, status };\n    } catch (err) {\n      recording.stopAndUnloadAsync();\n      throw err;\n    }\n  };\n\n  // Get status API\n\n  /**\n   * Gets the `status` of the `Recording`.\n   * @return A `Promise` that is resolved with the `RecordingStatus` object.\n   */\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  /**\n   * Sets a function to be called regularly with the `RecordingStatus` of the `Recording`.\n   *\n   * `onRecordingStatusUpdate` will be called when another call to the API for this recording completes (such as `prepareToRecordAsync()`,\n   * `startAsync()`, `getStatusAsync()`, or `stopAndUnloadAsync()`), and will also be called at regular intervals while the recording can record.\n   * Call `setProgressUpdateInterval()` to modify the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   *\n   * @param onRecordingStatusUpdate A function taking a single parameter `RecordingStatus`.\n   */\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  /**\n   * Sets the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   * See `setOnRecordingStatusUpdate` for details. This value defaults to 500 milliseconds.\n   * @param progressUpdateIntervalMillis The new interval between calls of `onRecordingStatusUpdate`.\n   */\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  /**\n   * Loads the recorder into memory and prepares it for recording. This must be called before calling `startAsync()`.\n   * This method can only be called if the `Recording` instance has never yet been prepared.\n   *\n   * @param options `RecordingOptions` for the recording, including sample rate, bitrate, channels, format, encoder, and extension.\n   * If no options are passed to `prepareToRecordAsync()`, the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`.\n   *\n   * @return A `Promise` that is fulfilled when the recorder is loaded and prepared, or rejects if this failed. If another `Recording` exists\n   * in your experience that is currently prepared to record, the `Promise` will reject. If the `RecordingOptions` provided are invalid,\n   * the `Promise` will also reject. The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async prepareToRecordAsync(\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string | null;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  /**\n   * Returns a list of available recording inputs. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with an array of `RecordingInput` objects.\n   */\n  async getAvailableInputs(): Promise<RecordingInput[]> {\n    return ExponentAV.getAvailableInputs();\n  }\n\n  /**\n   * Returns the currently-selected recording input. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with a `RecordingInput` object.\n   */\n  async getCurrentInput(): Promise<RecordingInput> {\n    return ExponentAV.getCurrentInput();\n  }\n\n  /**\n   * Sets the current recording input.\n   * @param inputUid The uid of a `RecordingInput`.\n   * @return A `Promise` that is resolved if successful or rejected if not.\n   */\n  async setInput(inputUid: string): Promise<void> {\n    return ExponentAV.setInput(inputUid);\n  }\n\n  /**\n   * Begins recording. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled when recording has begun, or rejects if recording could not be started.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  /**\n   * Pauses recording. This method can only be called if the `Recording` has been prepared.\n   *\n   * > This is only available on Android API version 24 and later.\n   *\n   * @return A `Promise` that is fulfilled when recording has paused, or rejects if recording could not be paused.\n   * If the Android API version is less than 24, the `Promise` will reject. The promise is resolved with the\n   * `RecordingStatus` of the recording.\n   */\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  /**\n   * Stops the recording and deallocates the recorder from memory. This reverts the `Recording` instance\n   * to an unprepared state, and another `Recording` instance must be created in order to record again.\n   * This method can only be called if the `Recording` has been prepared.\n   *\n   * > On Android this method may fail with `E_AUDIO_NODATA` when called too soon after `startAsync` and\n   * > no audio data has been recorded yet. In that case the recorded file will be invalid and should be discarded.\n   *\n   * @return A `Promise` that is fulfilled when recording has stopped, or rejects if recording could not be stopped.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    let stopResult: RecordingStatus | undefined;\n    let stopError: Error | undefined;\n    try {\n      stopResult = await ExponentAV.stopAudioRecording();\n    } catch (err) {\n      stopError = err;\n    }\n\n    // Web has to return the URI at the end of recording, so needs a little destructuring\n    if (Platform.OS === 'web' && stopResult?.uri !== undefined) {\n      this._uri = stopResult.uri;\n    }\n\n    // Clean-up and return status\n    await ExponentAV.unloadAudioRecorder();\n    const status = await this._cleanupForUnloadedRecorder(stopResult);\n    return stopError ? Promise.reject(stopError) : status;\n  }\n\n  // Read API\n\n  /**\n   * Gets the local URI of the `Recording`. Note that this will only succeed once the `Recording` is prepared\n   * to record. On web, this will not return the URI until the recording is finished.\n   * @return A `string` with the local URI of the `Recording`, or `null` if the `Recording` is not prepared\n   * to record (or, on Web, if the recording has not finished).\n   */\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  /**\n   * @deprecated Use `createNewLoadedSoundAsync()` instead.\n   */\n  async createNewLoadedSound(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  /**\n   * Creates and loads a new `Sound` object to play back the `Recording`. Note that this will only succeed once the `Recording`\n   * is done recording and `stopAndUnloadAsync()` has been called.\n   *\n   * @param initialStatus The initial intended `PlaybackStatusToSet` of the sound, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. See the [AV documentation](/versions/latest/sdk/av) for details on `PlaybackStatusToSet`\n   * and the default initial playback status.\n   * @param onPlaybackStatusUpdate A function taking a single parameter `PlaybackStatus`. This value defaults to `null` if no parameter is passed.\n   * See the [AV documentation](/versions/latest/sdk/av) for details on the functionality provided by `onPlaybackStatusUpdate`\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the `SoundObject`.\n   */\n  async createNewLoadedSoundAsync(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n\nexport { PermissionResponse, PermissionStatus, PermissionHookOptions };\n\nexport * from './RecordingConstants';\n\nexport * from './Recording.types';\n"]}
\ No newline at end of file
+{"version":3,"file":"Recording.js","sourceRoot":"","sources":["../../src/Audio/Recording.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  createPermissionHook,\n  EventEmitter,\n  Subscription,\n  Platform,\n} from 'expo-modules-core';\n\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport {\n  RecordingInput,\n  RecordingObject,\n  RecordingOptions,\n  RecordingStatus,\n} from './Recording.types';\nimport { RecordingOptionsPresets } from './RecordingConstants';\nimport { Sound, SoundObject } from './Sound';\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n} from '../AV';\nimport ExponentAV from '../ExponentAV';\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\n/**\n * Checks user's permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.getPermissionsAsync();\n}\n\n/**\n * Asks the user to grant permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.requestPermissionsAsync();\n}\n\n/**\n * Check or request permissions to record audio.\n * This uses both `requestPermissionAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [permissionResponse, requestPermission] = Audio.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * This class represents an audio recording. After creating an instance of this class, `prepareToRecordAsync`\n * must be called in order to record audio. Once recording is finished, call `stopAndUnloadAsync`. Note that\n * only one recorder is allowed to exist in the state between `prepareToRecordAsync` and `stopAndUnloadAsync`\n * at any given time.\n *\n * Note that your experience must request audio recording permissions in order for recording to function.\n * See the [`Permissions` module](/guides/permissions) for more details.\n *\n * Additionally, audio recording is [not supported in the iOS Simulator](/workflow/ios-simulator/#limitations).\n *\n * @example\n * ```ts\n * const recording = new Audio.Recording();\n * try {\n *   await recording.prepareToRecordAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY);\n *   await recording.startAsync();\n *   // You are now recording!\n * } catch (error) {\n *   // An error occurred!\n * }\n * ```\n *\n * @return A newly constructed instance of `Audio.Recording`.\n */\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus?: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    this._finalDurationMillis = finalStatus?.durationMillis ?? 0;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      ) as any;\n      try {\n        await this.getStatusAsync();\n      } catch {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  /**\n   * Creates and starts a recording using the given options, with optional `onRecordingStatusUpdate` and `progressUpdateIntervalMillis`.\n   *\n   * ```ts\n   * const { recording, status } = await Audio.Recording.createAsync(\n   *   options,\n   *   onRecordingStatusUpdate,\n   *   progressUpdateIntervalMillis\n   * );\n   *\n   * // Which is equivalent to the following:\n   * const recording = new Audio.Recording();\n   * await recording.prepareToRecordAsync(options);\n   * recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n   * await recording.startAsync();\n   * ```\n   *\n   * @param options Options for the recording, including sample rate, bitrate, channels, format, encoder, and extension. If no options are passed to,\n   * the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`. See below for details on `RecordingOptions`.\n   * @param onRecordingStatusUpdate A function taking a single parameter `status` (a dictionary, described in `getStatusAsync`).\n   * @param progressUpdateIntervalMillis The interval between calls of `onRecordingStatusUpdate`. This value defaults to 500 milliseconds.\n   *\n   * @example\n   * ```ts\n   * try {\n   *   const { recording: recordingObject, status } = await Audio.Recording.createAsync(\n   *     Audio.RecordingOptionsPresets.HIGH_QUALITY\n   *   );\n   *   // You are now recording!\n   * } catch (error) {\n   *   // An error occurred!\n   * }\n   * ```\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the following dictionary if creation succeeded.\n   */\n  static createAsync = async (\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY,\n    onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null,\n    progressUpdateIntervalMillis: number | null = null\n  ): Promise<RecordingObject> => {\n    const recording: Recording = new Recording();\n    if (progressUpdateIntervalMillis) {\n      recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    }\n    recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n    await recording.prepareToRecordAsync({\n      ...options,\n      keepAudioActiveHint: true,\n    });\n    try {\n      const status = await recording.startAsync();\n      return { recording, status };\n    } catch (err) {\n      recording.stopAndUnloadAsync();\n      throw err;\n    }\n  };\n\n  // Get status API\n\n  /**\n   * Gets the `status` of the `Recording`.\n   * @return A `Promise` that is resolved with the `RecordingStatus` object.\n   */\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  /**\n   * Sets a function to be called regularly with the `RecordingStatus` of the `Recording`.\n   *\n   * `onRecordingStatusUpdate` will be called when another call to the API for this recording completes (such as `prepareToRecordAsync()`,\n   * `startAsync()`, `getStatusAsync()`, or `stopAndUnloadAsync()`), and will also be called at regular intervals while the recording can record.\n   * Call `setProgressUpdateInterval()` to modify the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   *\n   * @param onRecordingStatusUpdate A function taking a single parameter `RecordingStatus`.\n   */\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  /**\n   * Sets the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   * See `setOnRecordingStatusUpdate` for details. This value defaults to 500 milliseconds.\n   * @param progressUpdateIntervalMillis The new interval between calls of `onRecordingStatusUpdate`.\n   */\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  /**\n   * Loads the recorder into memory and prepares it for recording. This must be called before calling `startAsync()`.\n   * This method can only be called if the `Recording` instance has never yet been prepared.\n   *\n   * @param options `RecordingOptions` for the recording, including sample rate, bitrate, channels, format, encoder, and extension.\n   * If no options are passed to `prepareToRecordAsync()`, the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`.\n   *\n   * @return A `Promise` that is fulfilled when the recorder is loaded and prepared, or rejects if this failed. If another `Recording` exists\n   * in your experience that is currently prepared to record, the `Promise` will reject. If the `RecordingOptions` provided are invalid,\n   * the `Promise` will also reject. The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async prepareToRecordAsync(\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string | null;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  /**\n   * Returns a list of available recording inputs. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with an array of `RecordingInput` objects.\n   */\n  async getAvailableInputs(): Promise<RecordingInput[]> {\n    return ExponentAV.getAvailableInputs();\n  }\n\n  /**\n   * Returns the currently-selected recording input. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with a `RecordingInput` object.\n   */\n  async getCurrentInput(): Promise<RecordingInput> {\n    return ExponentAV.getCurrentInput();\n  }\n\n  /**\n   * Sets the current recording input.\n   * @param inputUid The uid of a `RecordingInput`.\n   * @return A `Promise` that is resolved if successful or rejected if not.\n   */\n  async setInput(inputUid: string): Promise<void> {\n    return ExponentAV.setInput(inputUid);\n  }\n\n  /**\n   * Begins recording. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled when recording has begun, or rejects if recording could not be started.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  /**\n   * Pauses recording. This method can only be called if the `Recording` has been prepared.\n   *\n   * > This is only available on Android API version 24 and later.\n   *\n   * @return A `Promise` that is fulfilled when recording has paused, or rejects if recording could not be paused.\n   * If the Android API version is less than 24, the `Promise` will reject. The promise is resolved with the\n   * `RecordingStatus` of the recording.\n   */\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  /**\n   * Stops the recording and deallocates the recorder from memory. This reverts the `Recording` instance\n   * to an unprepared state, and another `Recording` instance must be created in order to record again.\n   * This method can only be called if the `Recording` has been prepared.\n   *\n   * > On Android this method may fail with `E_AUDIO_NODATA` when called too soon after `startAsync` and\n   * > no audio data has been recorded yet. In that case the recorded file will be invalid and should be discarded.\n   *\n   * @return A `Promise` that is fulfilled when recording has stopped, or rejects if recording could not be stopped.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    let stopResult: RecordingStatus | undefined;\n    let stopError: Error | undefined;\n    try {\n      stopResult = await ExponentAV.stopAudioRecording();\n    } catch (err) {\n      stopError = err;\n    }\n\n    // Web has to return the URI at the end of recording, so needs a little destructuring\n    if (Platform.OS === 'web' && stopResult?.uri !== undefined) {\n      this._uri = stopResult.uri;\n    }\n\n    // Clean-up and return status\n    await ExponentAV.unloadAudioRecorder();\n    const status = await this._cleanupForUnloadedRecorder(stopResult);\n    return stopError ? Promise.reject(stopError) : status;\n  }\n\n  // Read API\n\n  /**\n   * Gets the local URI of the `Recording`. Note that this will only succeed once the `Recording` is prepared\n   * to record. On web, this will not return the URI until the recording is finished.\n   * @return A `string` with the local URI of the `Recording`, or `null` if the `Recording` is not prepared\n   * to record (or, on Web, if the recording has not finished).\n   */\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  /**\n   * @deprecated Use `createNewLoadedSoundAsync()` instead.\n   */\n  async createNewLoadedSound(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  /**\n   * Creates and loads a new `Sound` object to play back the `Recording`. Note that this will only succeed once the `Recording`\n   * is done recording and `stopAndUnloadAsync()` has been called.\n   *\n   * @param initialStatus The initial intended `PlaybackStatusToSet` of the sound, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. See the [AV documentation](/versions/latest/sdk/av) for details on `PlaybackStatusToSet`\n   * and the default initial playback status.\n   * @param onPlaybackStatusUpdate A function taking a single parameter `PlaybackStatus`. This value defaults to `null` if no parameter is passed.\n   * See the [AV documentation](/versions/latest/sdk/av) for details on the functionality provided by `onPlaybackStatusUpdate`\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the `SoundObject`.\n   */\n  async createNewLoadedSoundAsync(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n\nexport { PermissionResponse, PermissionStatus, PermissionHookOptions };\n\nexport * from './RecordingConstants';\n\nexport * from './Recording.types';\n"]}
\ No newline at end of file
diff --git a/build/Audio/Sound.js.map b/build/Audio/Sound.js.map
index dd89feb757d05f5291ee167e33fd0044fdc741d7..9c4c624849819e10e44836c1d1ff6a5ee2202293 100644
--- a/build/Audio/Sound.js.map
+++ b/build/Audio/Sound.js.map
@@ -1 +1 @@
-{"version":3,"file":"Sound.js","sourceRoot":"","sources":["../../src/Audio/Sound.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter, Platform, UnavailabilityError } from 'expo-modules-core';\n\nimport { throwIfAudioIsDisabled } from './AudioAvailability';\nimport {\n  Playback,\n  PlaybackMixin,\n  AVPlaybackSource,\n  AVMetadata,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  assertStatusValuesInBounds,\n  getNativeSourceAndFullInitialStatusForLoadAsync,\n  getUnloadedStatus,\n  AVPlaybackTolerance,\n} from '../AV';\nimport { PitchCorrectionQuality } from '../Audio';\nimport ExponentAV from '../ExponentAV';\n\n// @needsAudit\nexport type AudioChannel = {\n  /**\n   * All samples for this specific Audio Channel in PCM Buffer format (-1 to 1).\n   */\n  frames: number[];\n};\n\n// @needsAudit\n/**\n * Object passed to the `onAudioSampleReceived` function. Represents a single sample from an audio source.\n * The sample contains all frames (PCM Buffer values) for each channel of the audio, so if the audio is _stereo_ (interleaved),\n * there will be two channels, one for left and one for right audio.\n */\nexport type AudioSample = {\n  /**\n   * An array representing the data from each channel in PCM Buffer format. Array elements are objects in the following format: `{ frames: number[] }`,\n   * where each frame is a number in PCM Buffer format (`-1` to `1` range).\n   */\n  channels: AudioChannel[];\n  /**\n   * A number representing the timestamp of the current sample in seconds, relative to the audio track's timeline.\n   * > **Known issue:** When using the `ExoPlayer` Android implementation, the timestamp is always `-1`.\n   */\n  timestamp: number;\n};\n\n// @needsAudit\nexport type SoundObject = {\n  /**\n   * The newly created and loaded `Sound` object.\n   */\n  sound: Sound;\n  /**\n   * The `PlaybackStatus` of the `Sound` object. See the [AV documentation](/versions/latest/sdk/av) for further information.\n   */\n  status: AVPlaybackStatus;\n};\n\ntype AudioInstance = number | HTMLMediaElement | null;\ntype AudioSampleCallback = ((sample: AudioSample) => void) | null;\n\ndeclare global {\n  interface Global {\n    __EXAV_setOnAudioSampleReceivedCallback:\n      | ((key: number, callback: AudioSampleCallback) => void)\n      | undefined;\n  }\n}\n\n// @needsAudit\n/**\n * This class represents a sound corresponding to an Asset or URL.\n * @return A newly constructed instance of `Audio.Sound`.\n *\n * @example\n * ```ts\n * const sound = new Audio.Sound();\n * try {\n *   await sound.loadAsync(require('./assets/sounds/hello.mp3'));\n *   await sound.playAsync();\n *   // Your sound is playing!\n *\n *   // Don't forget to unload the sound from memory\n *   // when you are done using the Sound object\n *   await sound.unloadAsync();\n * } catch (error) {\n *   // An error occurred!\n * }\n * ```\n *\n * > Method not described below and the rest of the API for `Audio.Sound` is the same as the imperative playback API for `Video`.\n * > See the [AV documentation](/versions/latest/sdk/av) for further information.\n */\nexport class Sound implements Playback {\n  _loaded: boolean = false;\n  _loading: boolean = false;\n  _key: AudioInstance = null;\n  _lastStatusUpdate: string | null = null;\n  _lastStatusUpdateTime: Date | null = null;\n  _subscriptions: { remove: () => void }[] = [];\n  _eventEmitter: EventEmitter = new EventEmitter(ExponentAV);\n  _coalesceStatusUpdatesInMillis: number = 100;\n  _onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null;\n  _onMetadataUpdate: ((metadata: AVMetadata) => void) | null = null;\n  _onAudioSampleReceived: AudioSampleCallback = null;\n\n  /** @deprecated Use `Sound.createAsync()` instead */\n  static create = async (\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null,\n    downloadFirst: boolean = true\n  ): Promise<SoundObject> => {\n    console.warn(\n      `Sound.create is deprecated in favor of Sound.createAsync with the same API except for the new method name`\n    );\n    return Sound.createAsync(source, initialStatus, onPlaybackStatusUpdate, downloadFirst);\n  };\n\n  /**\n   * Creates and loads a sound from source.\n   *\n   * ```ts\n   * const { sound } = await Audio.Sound.createAsync(\n   *   source,\n   *   initialStatus,\n   *   onPlaybackStatusUpdate,\n   *   downloadFirst\n   * );\n   *\n   * // Which is equivalent to the following:\n   * const sound = new Audio.Sound();\n   * sound.setOnPlaybackStatusUpdate(onPlaybackStatusUpdate);\n   * await sound.loadAsync(source, initialStatus, downloadFirst);\n   * ```\n   *\n   * @param source The source of the sound. See the [AV documentation](/versions/latest/sdk/av/#playback-api) for details on the possible `source` values.\n   *\n   * @param initialStatus The initial intended `PlaybackStatusToSet` of the sound, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. See the [AV documentation](/versions/latest/sdk/av) for details on `PlaybackStatusToSet` and the default\n   * initial playback status.\n   *\n   * @param onPlaybackStatusUpdate A function taking a single parameter `PlaybackStatus`. This value defaults to `null` if no parameter is passed.\n   * See the [AV documentation](/versions/latest/sdk/av) for details on the functionality provided by `onPlaybackStatusUpdate`\n   *\n   * @param downloadFirst If set to true, the system will attempt to download the resource to the device before loading. This value defaults to `true`.\n   * Note that at the moment, this will only work for `source`s of the form `require('path/to/file')` or `Asset` objects.\n   *\n   * @example\n   * ```ts\n   * try {\n   *   const { sound: soundObject, status } = await Audio.Sound.createAsync(\n   *     require('./assets/sounds/hello.mp3'),\n   *     { shouldPlay: true }\n   *   );\n   *   // Your sound is playing!\n   * } catch (error) {\n   *   // An error occurred!\n   * }\n   * ```\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the `SoundObject` if creation succeeded.\n   */\n  static createAsync = async (\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null,\n    downloadFirst: boolean = true\n  ): Promise<SoundObject> => {\n    const sound: Sound = new Sound();\n    sound.setOnPlaybackStatusUpdate(onPlaybackStatusUpdate);\n    const status: AVPlaybackStatus = await sound.loadAsync(source, initialStatus, downloadFirst);\n    return { sound, status };\n  };\n\n  // Internal methods\n\n  _callOnPlaybackStatusUpdateForNewStatus(status: AVPlaybackStatus) {\n    const shouldDismissBasedOnCoalescing =\n      this._lastStatusUpdateTime &&\n      JSON.stringify(status) === this._lastStatusUpdate &&\n      Date.now() - this._lastStatusUpdateTime.getTime() < this._coalesceStatusUpdatesInMillis;\n\n    if (this._onPlaybackStatusUpdate != null && !shouldDismissBasedOnCoalescing) {\n      this._onPlaybackStatusUpdate(status);\n      this._lastStatusUpdateTime = new Date();\n      this._lastStatusUpdate = JSON.stringify(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<AVPlaybackStatus>\n  ): Promise<AVPlaybackStatus> {\n    throwIfAudioIsDisabled();\n    if (this._loaded) {\n      const status = await operation();\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because sound is not loaded.');\n    }\n  }\n\n  private _updateAudioSampleReceivedCallback() {\n    if (globalThis.__EXAV_setOnAudioSampleReceivedCallback == null) {\n      if (Platform.OS === 'ios' || Platform.OS === 'android') {\n        console.warn(\n          'expo-av: Failed to set up Audio Sample Buffer callback. ' +\n            \"Do you have 'Remote Debugging' enabled in your app's Developer Menu (https://docs.expo.dev/workflow/debugging)? \" +\n            'Audio Sample Buffer callbacks are not supported while using Remote Debugging, you will need to disable it to use them.'\n        );\n        return;\n      } else {\n        throw new UnavailabilityError('expo-av', 'setOnAudioSampleReceived');\n      }\n    }\n    if (this._key == null) {\n      throw new Error(\n        'Cannot set Audio Sample Buffer callback when the Sound instance has not been successfully loaded/initialized!'\n      );\n    }\n    if (typeof this._key !== 'number') {\n      throw new Error(\n        `Cannot set Audio Sample Buffer callback when Sound instance key is of type ${typeof this\n          ._key}! (expected: number)`\n      );\n    }\n\n    globalThis.__EXAV_setOnAudioSampleReceivedCallback(this._key, this._onAudioSampleReceived);\n  }\n\n  _internalStatusUpdateCallback = ({\n    key,\n    status,\n  }: {\n    key: AudioInstance;\n    status: AVPlaybackStatus;\n  }) => {\n    if (this._key === key) {\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n    }\n  };\n\n  _internalMetadataUpdateCallback = ({\n    key,\n    metadata,\n  }: {\n    key: AudioInstance;\n    metadata: AVMetadata;\n  }) => {\n    if (this._key === key) {\n      this._onMetadataUpdate?.(metadata);\n    }\n  };\n\n  _internalErrorCallback = ({ key, error }: { key: AudioInstance; error: string }) => {\n    if (this._key === key) {\n      this._errorCallback(error);\n    }\n  };\n\n  // TODO: We can optimize by only using time observer on native if (this._onPlaybackStatusUpdate).\n  _subscribeToNativeEvents() {\n    if (this._loaded) {\n      this._subscriptions.push(\n        this._eventEmitter.addListener(\n          'didUpdatePlaybackStatus',\n          this._internalStatusUpdateCallback\n        ),\n        this._eventEmitter.addListener('didUpdateMetadata', this._internalMetadataUpdateCallback)\n      );\n\n      this._subscriptions.push(\n        this._eventEmitter.addListener('ExponentAV.onError', this._internalErrorCallback)\n      );\n    }\n  }\n\n  _clearSubscriptions() {\n    this._subscriptions.forEach((e) => e.remove());\n    this._subscriptions = [];\n  }\n\n  _errorCallback = (error: string) => {\n    this._clearSubscriptions();\n    this._loaded = false;\n    this._key = null;\n    this._callOnPlaybackStatusUpdateForNewStatus(getUnloadedStatus(error));\n  };\n\n  // ### Unified playback API ### (consistent with Video.js)\n  // All calls automatically call onPlaybackStatusUpdate as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<AVPlaybackStatus> => {\n    if (this._loaded) {\n      return this._performOperationAndHandleStatusAsync(() =>\n        ExponentAV.getStatusForSound(this._key)\n      );\n    }\n    const status: AVPlaybackStatus = getUnloadedStatus();\n    this._callOnPlaybackStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  /**\n   * Sets a function to be called regularly with the `AVPlaybackStatus` of the playback object.\n   *\n   * `onPlaybackStatusUpdate` will be called whenever a call to the API for this playback object completes\n   * (such as `setStatusAsync()`, `getStatusAsync()`, or `unloadAsync()`), nd will also be called at regular intervals\n   * while the media is in the loaded state.\n   *\n   * Set `progressUpdateIntervalMillis` via `setStatusAsync()` or `setProgressUpdateIntervalAsync()` to modify\n   * the interval with which `onPlaybackStatusUpdate` is called while loaded.\n   *\n   * @param onPlaybackStatusUpdate A function taking a single parameter `AVPlaybackStatus`.\n   */\n  setOnPlaybackStatusUpdate(onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null) {\n    this._onPlaybackStatusUpdate = onPlaybackStatusUpdate;\n    this.getStatusAsync();\n  }\n\n  /**\n   * Sets a function to be called whenever the metadata of the sound object changes, if one is set.\n   * @param onMetadataUpdate A function taking a single object of type `AVMetadata` as a parameter.\n   * @platform ios\n   */\n  setOnMetadataUpdate(onMetadataUpdate: (metadata: AVMetadata) => void) {\n    this._onMetadataUpdate = onMetadataUpdate;\n  }\n\n  /**\n   * Sets a function to be called during playback, receiving the audio sample as parameter.\n   * @param callback A function taking the `AudioSampleCallback` as parameter.\n   */\n  setOnAudioSampleReceived(callback: AudioSampleCallback) {\n    this._onAudioSampleReceived = callback;\n    if (this._key != null) {\n      this._updateAudioSampleReceivedCallback();\n    }\n  }\n\n  // Loading / unloading API\n\n  async loadAsync(\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet = {},\n    downloadFirst: boolean = true\n  ): Promise<AVPlaybackStatus> {\n    throwIfAudioIsDisabled();\n    if (this._loading) {\n      throw new Error('The Sound is already loading.');\n    }\n    if (!this._loaded) {\n      this._loading = true;\n\n      const { nativeSource, fullInitialStatus } =\n        await getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst);\n\n      // This is a workaround, since using load with resolve / reject seems to not work.\n      return new Promise<AVPlaybackStatus>((resolve, reject) => {\n        const loadSuccess = (result: [AudioInstance, AVPlaybackStatus]) => {\n          const [key, status] = result;\n          this._key = key;\n          this._loaded = true;\n          this._loading = false;\n          this._subscribeToNativeEvents();\n          this._callOnPlaybackStatusUpdateForNewStatus(status);\n          resolve(status);\n        };\n\n        const loadError = (error: Error) => {\n          this._loading = false;\n          reject(error);\n        };\n\n        ExponentAV.loadForSound(nativeSource, fullInitialStatus).then(loadSuccess).catch(loadError);\n      });\n    } else {\n      throw new Error('The Sound is already loaded.');\n    }\n  }\n\n  async unloadAsync(): Promise<AVPlaybackStatus> {\n    if (this._loaded) {\n      this._loaded = false;\n      const key = this._key;\n      this._key = null;\n      const status = await ExponentAV.unloadForSound(key);\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n      this._clearSubscriptions();\n      return status;\n    } else {\n      return this.getStatusAsync(); // Automatically calls onPlaybackStatusUpdate.\n    }\n  }\n\n  // Set status API (only available while isLoaded = true)\n\n  async setStatusAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus> {\n    assertStatusValuesInBounds(status);\n    return this._performOperationAndHandleStatusAsync(() =>\n      ExponentAV.setStatusForSound(this._key, status)\n    );\n  }\n\n  async replayAsync(status: AVPlaybackStatusToSet = {}): Promise<AVPlaybackStatus> {\n    if (status.positionMillis && status.positionMillis !== 0) {\n      throw new Error('Requested position after replay has to be 0.');\n    }\n\n    return this._performOperationAndHandleStatusAsync(() =>\n      ExponentAV.replaySound(this._key, {\n        ...status,\n        positionMillis: 0,\n        shouldPlay: true,\n      })\n    );\n  }\n\n  // Methods of the Playback interface that are set via PlaybackMixin\n  playAsync!: () => Promise<AVPlaybackStatus>;\n  playFromPositionAsync!: (\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ) => Promise<AVPlaybackStatus>;\n  pauseAsync!: () => Promise<AVPlaybackStatus>;\n  stopAsync!: () => Promise<AVPlaybackStatus>;\n  setPositionAsync!: (\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ) => Promise<AVPlaybackStatus>;\n  setRateAsync!: (\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ) => Promise<AVPlaybackStatus>;\n  setVolumeAsync!: (volume: number, audioPan?: number) => Promise<AVPlaybackStatus>;\n  setIsMutedAsync!: (isMuted: boolean) => Promise<AVPlaybackStatus>;\n  setIsLoopingAsync!: (isLooping: boolean) => Promise<AVPlaybackStatus>;\n  setProgressUpdateIntervalAsync!: (\n    progressUpdateIntervalMillis: number\n  ) => Promise<AVPlaybackStatus>;\n}\n\nObject.assign(Sound.prototype, PlaybackMixin);\n"]}
\ No newline at end of file
+{"version":3,"file":"Sound.js","sourceRoot":"","sources":["../../src/Audio/Sound.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter, Platform, UnavailabilityError } from 'expo-modules-core';\n\nimport { throwIfAudioIsDisabled } from './AudioAvailability';\nimport {\n  Playback,\n  PlaybackMixin,\n  AVPlaybackSource,\n  AVMetadata,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  assertStatusValuesInBounds,\n  getNativeSourceAndFullInitialStatusForLoadAsync,\n  getUnloadedStatus,\n  AVPlaybackTolerance,\n} from '../AV';\nimport { PitchCorrectionQuality } from '../Audio';\nimport ExponentAV from '../ExponentAV';\n\n// @needsAudit\nexport type AudioChannel = {\n  /**\n   * All samples for this specific Audio Channel in PCM Buffer format (-1 to 1).\n   */\n  frames: number[];\n};\n\n// @needsAudit\n/**\n * Object passed to the `onAudioSampleReceived` function. Represents a single sample from an audio source.\n * The sample contains all frames (PCM Buffer values) for each channel of the audio, so if the audio is _stereo_ (interleaved),\n * there will be two channels, one for left and one for right audio.\n */\nexport type AudioSample = {\n  /**\n   * An array representing the data from each channel in PCM Buffer format. Array elements are objects in the following format: `{ frames: number[] }`,\n   * where each frame is a number in PCM Buffer format (`-1` to `1` range).\n   */\n  channels: AudioChannel[];\n  /**\n   * A number representing the timestamp of the current sample in seconds, relative to the audio track's timeline.\n   * > **Known issue:** When using the `ExoPlayer` Android implementation, the timestamp is always `-1`.\n   */\n  timestamp: number;\n};\n\n// @needsAudit\nexport type SoundObject = {\n  /**\n   * The newly created and loaded `Sound` object.\n   */\n  sound: Sound;\n  /**\n   * The `PlaybackStatus` of the `Sound` object. See the [AV documentation](/versions/latest/sdk/av) for further information.\n   */\n  status: AVPlaybackStatus;\n};\n\ntype AudioInstance = number | HTMLMediaElement | null;\ntype AudioSampleCallback = ((sample: AudioSample) => void) | null;\n\ndeclare global {\n  interface Global {\n    __EXAV_setOnAudioSampleReceivedCallback:\n      | ((key: number, callback: AudioSampleCallback) => void)\n      | undefined;\n  }\n}\n\n// @needsAudit\n/**\n * This class represents a sound corresponding to an Asset or URL.\n * @return A newly constructed instance of `Audio.Sound`.\n *\n * @example\n * ```ts\n * const sound = new Audio.Sound();\n * try {\n *   await sound.loadAsync(require('./assets/sounds/hello.mp3'));\n *   await sound.playAsync();\n *   // Your sound is playing!\n *\n *   // Don't forget to unload the sound from memory\n *   // when you are done using the Sound object\n *   await sound.unloadAsync();\n * } catch (error) {\n *   // An error occurred!\n * }\n * ```\n *\n * > Method not described below and the rest of the API for `Audio.Sound` is the same as the imperative playback API for `Video`.\n * > See the [AV documentation](/versions/latest/sdk/av) for further information.\n */\nexport class Sound implements Playback {\n  _loaded: boolean = false;\n  _loading: boolean = false;\n  _key: AudioInstance = null;\n  _lastStatusUpdate: string | null = null;\n  _lastStatusUpdateTime: Date | null = null;\n  _subscriptions: { remove: () => void }[] = [];\n  _eventEmitter: EventEmitter = new EventEmitter(ExponentAV);\n  _coalesceStatusUpdatesInMillis: number = 100;\n  _onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null;\n  _onMetadataUpdate: ((metadata: AVMetadata) => void) | null = null;\n  _onAudioSampleReceived: AudioSampleCallback = null;\n\n  /** @deprecated Use `Sound.createAsync()` instead */\n  static create = async (\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null,\n    downloadFirst: boolean = true\n  ): Promise<SoundObject> => {\n    console.warn(\n      `Sound.create is deprecated in favor of Sound.createAsync with the same API except for the new method name`\n    );\n    return Sound.createAsync(source, initialStatus, onPlaybackStatusUpdate, downloadFirst);\n  };\n\n  /**\n   * Creates and loads a sound from source.\n   *\n   * ```ts\n   * const { sound } = await Audio.Sound.createAsync(\n   *   source,\n   *   initialStatus,\n   *   onPlaybackStatusUpdate,\n   *   downloadFirst\n   * );\n   *\n   * // Which is equivalent to the following:\n   * const sound = new Audio.Sound();\n   * sound.setOnPlaybackStatusUpdate(onPlaybackStatusUpdate);\n   * await sound.loadAsync(source, initialStatus, downloadFirst);\n   * ```\n   *\n   * @param source The source of the sound. See the [AV documentation](/versions/latest/sdk/av/#playback-api) for details on the possible `source` values.\n   *\n   * @param initialStatus The initial intended `PlaybackStatusToSet` of the sound, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. See the [AV documentation](/versions/latest/sdk/av) for details on `PlaybackStatusToSet` and the default\n   * initial playback status.\n   *\n   * @param onPlaybackStatusUpdate A function taking a single parameter `PlaybackStatus`. This value defaults to `null` if no parameter is passed.\n   * See the [AV documentation](/versions/latest/sdk/av) for details on the functionality provided by `onPlaybackStatusUpdate`\n   *\n   * @param downloadFirst If set to true, the system will attempt to download the resource to the device before loading. This value defaults to `true`.\n   * Note that at the moment, this will only work for `source`s of the form `require('path/to/file')` or `Asset` objects.\n   *\n   * @example\n   * ```ts\n   * try {\n   *   const { sound: soundObject, status } = await Audio.Sound.createAsync(\n   *     require('./assets/sounds/hello.mp3'),\n   *     { shouldPlay: true }\n   *   );\n   *   // Your sound is playing!\n   * } catch (error) {\n   *   // An error occurred!\n   * }\n   * ```\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the `SoundObject` if creation succeeded.\n   */\n  static createAsync = async (\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null,\n    downloadFirst: boolean = true\n  ): Promise<SoundObject> => {\n    const sound: Sound = new Sound();\n    sound.setOnPlaybackStatusUpdate(onPlaybackStatusUpdate);\n    const status: AVPlaybackStatus = await sound.loadAsync(source, initialStatus, downloadFirst);\n    return { sound, status };\n  };\n\n  // Internal methods\n\n  _callOnPlaybackStatusUpdateForNewStatus(status: AVPlaybackStatus) {\n    const shouldDismissBasedOnCoalescing =\n      this._lastStatusUpdateTime &&\n      JSON.stringify(status) === this._lastStatusUpdate &&\n      Date.now() - this._lastStatusUpdateTime.getTime() < this._coalesceStatusUpdatesInMillis;\n\n    if (this._onPlaybackStatusUpdate != null && !shouldDismissBasedOnCoalescing) {\n      this._onPlaybackStatusUpdate(status);\n      this._lastStatusUpdateTime = new Date();\n      this._lastStatusUpdate = JSON.stringify(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<AVPlaybackStatus>\n  ): Promise<AVPlaybackStatus> {\n    throwIfAudioIsDisabled();\n    if (this._loaded) {\n      const status = await operation();\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because sound is not loaded.');\n    }\n  }\n\n  private _updateAudioSampleReceivedCallback() {\n    if (globalThis.__EXAV_setOnAudioSampleReceivedCallback == null) {\n      if (Platform.OS === 'ios' || Platform.OS === 'android') {\n        console.warn(\n          'expo-av: Failed to set up Audio Sample Buffer callback. ' +\n            \"Do you have 'Remote Debugging' enabled in your app's Developer Menu (https://docs.expo.dev/workflow/debugging)? \" +\n            'Audio Sample Buffer callbacks are not supported while using Remote Debugging, you will need to disable it to use them.'\n        );\n        return;\n      } else {\n        throw new UnavailabilityError('expo-av', 'setOnAudioSampleReceived');\n      }\n    }\n    if (this._key == null) {\n      throw new Error(\n        'Cannot set Audio Sample Buffer callback when the Sound instance has not been successfully loaded/initialized!'\n      );\n    }\n    if (typeof this._key !== 'number') {\n      throw new Error(\n        `Cannot set Audio Sample Buffer callback when Sound instance key is of type ${typeof this\n          ._key}! (expected: number)`\n      );\n    }\n\n    globalThis.__EXAV_setOnAudioSampleReceivedCallback(this._key, this._onAudioSampleReceived);\n  }\n\n  _internalStatusUpdateCallback = ({\n    key,\n    status,\n  }: {\n    key: AudioInstance;\n    status: AVPlaybackStatus;\n  }) => {\n    if (this._key === key) {\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n    }\n  };\n\n  _internalMetadataUpdateCallback = ({\n    key,\n    metadata,\n  }: {\n    key: AudioInstance;\n    metadata: AVMetadata;\n  }) => {\n    if (this._key === key) {\n      this._onMetadataUpdate?.(metadata);\n    }\n  };\n\n  _internalErrorCallback = ({ key, error }: { key: AudioInstance; error: string }) => {\n    if (this._key === key) {\n      this._errorCallback(error);\n    }\n  };\n\n  // TODO: We can optimize by only using time observer on native if (this._onPlaybackStatusUpdate).\n  _subscribeToNativeEvents() {\n    if (this._loaded) {\n      this._subscriptions.push(\n        this._eventEmitter.addListener(\n          'didUpdatePlaybackStatus',\n          this._internalStatusUpdateCallback\n        ),\n        this._eventEmitter.addListener('didUpdateMetadata', this._internalMetadataUpdateCallback)\n      );\n\n      this._subscriptions.push(\n        this._eventEmitter.addListener('ExponentAV.onError', this._internalErrorCallback)\n      );\n    }\n  }\n\n  _clearSubscriptions() {\n    this._subscriptions.forEach((e) => e.remove());\n    this._subscriptions = [];\n  }\n\n  _errorCallback = (error: string) => {\n    this._clearSubscriptions();\n    this._loaded = false;\n    this._key = null;\n    this._callOnPlaybackStatusUpdateForNewStatus(getUnloadedStatus(error));\n  };\n\n  // ### Unified playback API ### (consistent with Video.js)\n  // All calls automatically call onPlaybackStatusUpdate as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<AVPlaybackStatus> => {\n    if (this._loaded) {\n      return this._performOperationAndHandleStatusAsync(() =>\n        ExponentAV.getStatusForSound(this._key)\n      );\n    }\n    const status: AVPlaybackStatus = getUnloadedStatus();\n    this._callOnPlaybackStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  /**\n   * Sets a function to be called regularly with the `AVPlaybackStatus` of the playback object.\n   *\n   * `onPlaybackStatusUpdate` will be called whenever a call to the API for this playback object completes\n   * (such as `setStatusAsync()`, `getStatusAsync()`, or `unloadAsync()`), nd will also be called at regular intervals\n   * while the media is in the loaded state.\n   *\n   * Set `progressUpdateIntervalMillis` via `setStatusAsync()` or `setProgressUpdateIntervalAsync()` to modify\n   * the interval with which `onPlaybackStatusUpdate` is called while loaded.\n   *\n   * @param onPlaybackStatusUpdate A function taking a single parameter `AVPlaybackStatus`.\n   */\n  setOnPlaybackStatusUpdate(onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null) {\n    this._onPlaybackStatusUpdate = onPlaybackStatusUpdate;\n    this.getStatusAsync();\n  }\n\n  /**\n   * Sets a function to be called whenever the metadata of the sound object changes, if one is set.\n   * @param onMetadataUpdate A function taking a single object of type `AVMetadata` as a parameter.\n   * @platform ios\n   */\n  setOnMetadataUpdate(onMetadataUpdate: (metadata: AVMetadata) => void) {\n    this._onMetadataUpdate = onMetadataUpdate;\n  }\n\n  /**\n   * Sets a function to be called during playback, receiving the audio sample as parameter.\n   * @param callback A function taking the `AudioSampleCallback` as parameter.\n   */\n  setOnAudioSampleReceived(callback: AudioSampleCallback) {\n    this._onAudioSampleReceived = callback;\n    if (this._key != null) {\n      this._updateAudioSampleReceivedCallback();\n    }\n  }\n\n  // Loading / unloading API\n\n  async loadAsync(\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet = {},\n    downloadFirst: boolean = true\n  ): Promise<AVPlaybackStatus> {\n    throwIfAudioIsDisabled();\n    if (this._loading) {\n      throw new Error('The Sound is already loading.');\n    }\n    if (!this._loaded) {\n      this._loading = true;\n\n      const { nativeSource, fullInitialStatus } =\n        await getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst);\n\n      // This is a workaround, since using load with resolve / reject seems to not work.\n      return new Promise<AVPlaybackStatus>((resolve, reject) => {\n        const loadSuccess = (result: [AudioInstance, AVPlaybackStatus]) => {\n          const [key, status] = result;\n          this._key = key;\n          this._loaded = true;\n          this._loading = false;\n          this._subscribeToNativeEvents();\n          this._callOnPlaybackStatusUpdateForNewStatus(status);\n          resolve(status);\n        };\n\n        const loadError = (error: Error) => {\n          this._loading = false;\n          reject(error);\n        };\n\n        ExponentAV.loadForSound(nativeSource, fullInitialStatus).then(loadSuccess).catch(loadError);\n      });\n    } else {\n      throw new Error('The Sound is already loaded.');\n    }\n  }\n\n  async unloadAsync(): Promise<AVPlaybackStatus> {\n    if (this._loaded) {\n      this._loaded = false;\n      const key = this._key;\n      this._key = null;\n      const status = await ExponentAV.unloadForSound(key);\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n      this._clearSubscriptions();\n      return status;\n    } else {\n      return this.getStatusAsync(); // Automatically calls onPlaybackStatusUpdate.\n    }\n  }\n\n  // Set status API (only available while isLoaded = true)\n\n  async setStatusAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus> {\n    assertStatusValuesInBounds(status);\n    return this._performOperationAndHandleStatusAsync(() =>\n      ExponentAV.setStatusForSound(this._key, status)\n    );\n  }\n\n  async replayAsync(status: AVPlaybackStatusToSet = {}): Promise<AVPlaybackStatus> {\n    if (status.positionMillis && status.positionMillis !== 0) {\n      throw new Error('Requested position after replay has to be 0.');\n    }\n\n    return this._performOperationAndHandleStatusAsync(() =>\n      ExponentAV.replaySound(this._key, {\n        ...status,\n        positionMillis: 0,\n        shouldPlay: true,\n      })\n    );\n  }\n\n  // Methods of the Playback interface that are set via PlaybackMixin\n  playAsync!: () => Promise<AVPlaybackStatus>;\n  playFromPositionAsync!: (\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ) => Promise<AVPlaybackStatus>;\n  pauseAsync!: () => Promise<AVPlaybackStatus>;\n  stopAsync!: () => Promise<AVPlaybackStatus>;\n  setPositionAsync!: (\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ) => Promise<AVPlaybackStatus>;\n  setRateAsync!: (\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ) => Promise<AVPlaybackStatus>;\n  setVolumeAsync!: (volume: number, audioPan?: number) => Promise<AVPlaybackStatus>;\n  setIsMutedAsync!: (isMuted: boolean) => Promise<AVPlaybackStatus>;\n  setIsLoopingAsync!: (isLooping: boolean) => Promise<AVPlaybackStatus>;\n  setProgressUpdateIntervalAsync!: (\n    progressUpdateIntervalMillis: number\n  ) => Promise<AVPlaybackStatus>;\n}\n\nObject.assign(Sound.prototype, PlaybackMixin);\n"]}
\ No newline at end of file
diff --git a/build/Audio.js.map b/build/Audio.js.map
index bf239e2469ade218d5c8ce311179908ef978663e..db72513f7ff6bc9f40dcfed7e1b00bbf1e28f2ea 100644
--- a/build/Audio.js.map
+++ b/build/Audio.js.map
@@ -1 +1 @@
-{"version":3,"file":"Audio.js","sourceRoot":"","sources":["../src/Audio.ts"],"names":[],"mappings":"AAAA,OAAO,EAAa,uBAAuB,EAAE,mBAAmB,EAAE,MAAM,eAAe,CAAC;AACxF,OAAO,UAAU,MAAM,cAAc,CAAC;AAEtC,cAAc,mBAAmB,CAAC;AAClC,cAAc,eAAe,CAAC;AAC9B,OAAO,EAAE,iBAAiB,EAAE,MAAM,2BAA2B,CAAC;AAC9D,OAAO,EAAE,sBAAsB,EAAE,MAAM,MAAM,CAAC;AAE9C,MAAM,oBAAoB,GAAG,CAC3B,aAAiC,EACjC,gBAA2B,EAChB,EAAE;IACb,KAAK,MAAM,GAAG,IAAI,gBAAgB,EAAE;QAClC,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;YACtC,aAAa,CAAC,GAAG,CAAC,GAAG,gBAAgB,CAAC,GAAG,CAAC,CAAC;SAC5C;KACF;IACD,OAAO,aAA0B,CAAC;AACpC,CAAC,CAAC;AAEF,MAAM,WAAW,GAAc;IAC7B,kBAAkB,EAAE,KAAK;IACzB,mBAAmB,EAAE,mBAAmB,CAAC,aAAa;IACtD,oBAAoB,EAAE,KAAK;IAC3B,uBAAuB,EAAE,KAAK;IAC9B,uBAAuB,EAAE,uBAAuB,CAAC,UAAU;IAC3D,iBAAiB,EAAE,IAAI;IACvB,0BAA0B,EAAE,KAAK;CAClC,CAAC;AAEF,IAAI,gBAAgB,GAAqB,IAAI,CAAC;AAE9C,SAAS,mBAAmB;IAC1B,IAAI,CAAC,gBAAgB,EAAE;QACrB,OAAO,WAAW,CAAC;KACpB;IACD,OAAO,gBAAgB,CAAC;AAC1B,CAAC;AAED;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,iBAAiB,CAAC,WAA+B;IACrE,MAAM,IAAI,GAAG,oBAAoB,CAAC,WAAW,EAAE,mBAAmB,EAAE,CAAC,CAAC;IAEtE,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,mBAAmB,CAAC,EAAE;QAClD,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;KACvE;IACD,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,uBAAuB,CAAC,EAAE;QAC1D,MAAM,IAAI,KAAK,CAAC,wDAAwD,CAAC,CAAC;KAC3E;IACD,IACE,OAAO,IAAI,CAAC,kBAAkB,KAAK,SAAS;QAC5C,OAAO,IAAI,CAAC,oBAAoB,KAAK,SAAS;QAC9C,OAAO,IAAI,CAAC,uBAAuB,KAAK,SAAS;QACjD,OAAO,IAAI,CAAC,iBAAiB,KAAK,SAAS;QAC3C,OAAO,IAAI,CAAC,0BAA0B,KAAK,SAAS,EACpD;QACA,MAAM,IAAI,KAAK,CACb,iJAAiJ,CAClJ,CAAC;KACH;IACD,gBAAgB,GAAG,IAAI,CAAC;IACxB,OAAO,MAAM,UAAU,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;AAC7C,CAAC","sourcesContent":["import { AudioMode, InterruptionModeAndroid, InterruptionModeIOS } from './Audio.types';\nimport ExponentAV from './ExponentAV';\n\nexport * from './Audio/Recording';\nexport * from './Audio/Sound';\nexport { setIsEnabledAsync } from './Audio/AudioAvailability';\nexport { PitchCorrectionQuality } from './AV';\n\nconst _populateMissingKeys = (\n  userAudioMode: Partial<AudioMode>,\n  defaultAudioMode: AudioMode\n): AudioMode => {\n  for (const key in defaultAudioMode) {\n    if (!userAudioMode.hasOwnProperty(key)) {\n      userAudioMode[key] = defaultAudioMode[key];\n    }\n  }\n  return userAudioMode as AudioMode;\n};\n\nconst defaultMode: AudioMode = {\n  allowsRecordingIOS: false,\n  interruptionModeIOS: InterruptionModeIOS.MixWithOthers,\n  playsInSilentModeIOS: false,\n  staysActiveInBackground: false,\n  interruptionModeAndroid: InterruptionModeAndroid.DuckOthers,\n  shouldDuckAndroid: true,\n  playThroughEarpieceAndroid: false,\n};\n\nlet currentAudioMode: AudioMode | null = null;\n\nfunction getCurrentAudioMode(): AudioMode {\n  if (!currentAudioMode) {\n    return defaultMode;\n  }\n  return currentAudioMode;\n}\n\n/**\n * We provide this API to customize the audio experience on iOS and Android.\n * @param partialMode\n * @return A `Promise` that will reject if the audio mode could not be enabled for the device.\n */\nexport async function setAudioModeAsync(partialMode: Partial<AudioMode>): Promise<void> {\n  const mode = _populateMissingKeys(partialMode, getCurrentAudioMode());\n\n  if (!InterruptionModeIOS[mode.interruptionModeIOS]) {\n    throw new Error(`\"interruptionModeIOS\" was set to an invalid value.`);\n  }\n  if (!InterruptionModeAndroid[mode.interruptionModeAndroid]) {\n    throw new Error(`\"interruptionModeAndroid\" was set to an invalid value.`);\n  }\n  if (\n    typeof mode.allowsRecordingIOS !== 'boolean' ||\n    typeof mode.playsInSilentModeIOS !== 'boolean' ||\n    typeof mode.staysActiveInBackground !== 'boolean' ||\n    typeof mode.shouldDuckAndroid !== 'boolean' ||\n    typeof mode.playThroughEarpieceAndroid !== 'boolean'\n  ) {\n    throw new Error(\n      '\"allowsRecordingIOS\", \"playsInSilentModeIOS\", \"playThroughEarpieceAndroid\", \"staysActiveInBackground\" and \"shouldDuckAndroid\" must be booleans.'\n    );\n  }\n  currentAudioMode = mode;\n  return await ExponentAV.setAudioMode(mode);\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"Audio.js","sourceRoot":"","sources":["../src/Audio.ts"],"names":[],"mappings":"AAAA,OAAO,EAAa,uBAAuB,EAAE,mBAAmB,EAAE,MAAM,eAAe,CAAC;AACxF,OAAO,UAAU,MAAM,cAAc,CAAC;AAEtC,cAAc,mBAAmB,CAAC;AAClC,cAAc,eAAe,CAAC;AAC9B,OAAO,EAAE,iBAAiB,EAAE,MAAM,2BAA2B,CAAC;AAC9D,OAAO,EAAE,sBAAsB,EAAE,MAAM,MAAM,CAAC;AAE9C,MAAM,oBAAoB,GAAG,CAC3B,aAAiC,EACjC,gBAA2B,EAChB,EAAE;IACb,KAAK,MAAM,GAAG,IAAI,gBAAgB,EAAE,CAAC;QACnC,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE,CAAC;YACvC,aAAa,CAAC,GAAG,CAAC,GAAG,gBAAgB,CAAC,GAAG,CAAC,CAAC;QAC7C,CAAC;IACH,CAAC;IACD,OAAO,aAA0B,CAAC;AACpC,CAAC,CAAC;AAEF,MAAM,WAAW,GAAc;IAC7B,kBAAkB,EAAE,KAAK;IACzB,mBAAmB,EAAE,mBAAmB,CAAC,aAAa;IACtD,oBAAoB,EAAE,KAAK;IAC3B,uBAAuB,EAAE,KAAK;IAC9B,uBAAuB,EAAE,uBAAuB,CAAC,UAAU;IAC3D,iBAAiB,EAAE,IAAI;IACvB,0BAA0B,EAAE,KAAK;CAClC,CAAC;AAEF,IAAI,gBAAgB,GAAqB,IAAI,CAAC;AAE9C,SAAS,mBAAmB;IAC1B,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACtB,OAAO,WAAW,CAAC;IACrB,CAAC;IACD,OAAO,gBAAgB,CAAC;AAC1B,CAAC;AAED;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,iBAAiB,CAAC,WAA+B;IACrE,MAAM,IAAI,GAAG,oBAAoB,CAAC,WAAW,EAAE,mBAAmB,EAAE,CAAC,CAAC;IAEtE,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,mBAAmB,CAAC,EAAE,CAAC;QACnD,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;IACxE,CAAC;IACD,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,uBAAuB,CAAC,EAAE,CAAC;QAC3D,MAAM,IAAI,KAAK,CAAC,wDAAwD,CAAC,CAAC;IAC5E,CAAC;IACD,IACE,OAAO,IAAI,CAAC,kBAAkB,KAAK,SAAS;QAC5C,OAAO,IAAI,CAAC,oBAAoB,KAAK,SAAS;QAC9C,OAAO,IAAI,CAAC,uBAAuB,KAAK,SAAS;QACjD,OAAO,IAAI,CAAC,iBAAiB,KAAK,SAAS;QAC3C,OAAO,IAAI,CAAC,0BAA0B,KAAK,SAAS,EACpD,CAAC;QACD,MAAM,IAAI,KAAK,CACb,iJAAiJ,CAClJ,CAAC;IACJ,CAAC;IACD,gBAAgB,GAAG,IAAI,CAAC;IACxB,OAAO,MAAM,UAAU,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;AAC7C,CAAC","sourcesContent":["import { AudioMode, InterruptionModeAndroid, InterruptionModeIOS } from './Audio.types';\nimport ExponentAV from './ExponentAV';\n\nexport * from './Audio/Recording';\nexport * from './Audio/Sound';\nexport { setIsEnabledAsync } from './Audio/AudioAvailability';\nexport { PitchCorrectionQuality } from './AV';\n\nconst _populateMissingKeys = (\n  userAudioMode: Partial<AudioMode>,\n  defaultAudioMode: AudioMode\n): AudioMode => {\n  for (const key in defaultAudioMode) {\n    if (!userAudioMode.hasOwnProperty(key)) {\n      userAudioMode[key] = defaultAudioMode[key];\n    }\n  }\n  return userAudioMode as AudioMode;\n};\n\nconst defaultMode: AudioMode = {\n  allowsRecordingIOS: false,\n  interruptionModeIOS: InterruptionModeIOS.MixWithOthers,\n  playsInSilentModeIOS: false,\n  staysActiveInBackground: false,\n  interruptionModeAndroid: InterruptionModeAndroid.DuckOthers,\n  shouldDuckAndroid: true,\n  playThroughEarpieceAndroid: false,\n};\n\nlet currentAudioMode: AudioMode | null = null;\n\nfunction getCurrentAudioMode(): AudioMode {\n  if (!currentAudioMode) {\n    return defaultMode;\n  }\n  return currentAudioMode;\n}\n\n/**\n * We provide this API to customize the audio experience on iOS and Android.\n * @param partialMode\n * @return A `Promise` that will reject if the audio mode could not be enabled for the device.\n */\nexport async function setAudioModeAsync(partialMode: Partial<AudioMode>): Promise<void> {\n  const mode = _populateMissingKeys(partialMode, getCurrentAudioMode());\n\n  if (!InterruptionModeIOS[mode.interruptionModeIOS]) {\n    throw new Error(`\"interruptionModeIOS\" was set to an invalid value.`);\n  }\n  if (!InterruptionModeAndroid[mode.interruptionModeAndroid]) {\n    throw new Error(`\"interruptionModeAndroid\" was set to an invalid value.`);\n  }\n  if (\n    typeof mode.allowsRecordingIOS !== 'boolean' ||\n    typeof mode.playsInSilentModeIOS !== 'boolean' ||\n    typeof mode.staysActiveInBackground !== 'boolean' ||\n    typeof mode.shouldDuckAndroid !== 'boolean' ||\n    typeof mode.playThroughEarpieceAndroid !== 'boolean'\n  ) {\n    throw new Error(\n      '\"allowsRecordingIOS\", \"playsInSilentModeIOS\", \"playThroughEarpieceAndroid\", \"staysActiveInBackground\" and \"shouldDuckAndroid\" must be booleans.'\n    );\n  }\n  currentAudioMode = mode;\n  return await ExponentAV.setAudioMode(mode);\n}\n"]}
\ No newline at end of file
diff --git a/build/ExpoVideoManager.web.js.map b/build/ExpoVideoManager.web.js.map
index 848c4fe9d55a51d25006e1f85c9eff097dd5e7a1..d4ccb35d15221f6277637d0a20c423dff1cf5b18 100644
--- a/build/ExpoVideoManager.web.js.map
+++ b/build/ExpoVideoManager.web.js.map
@@ -1 +1 @@
-{"version":3,"file":"ExpoVideoManager.web.js","sourceRoot":"","sources":["../src/ExpoVideoManager.web.ts"],"names":[],"mappings":"AACA,OAAO,UAAU,MAAM,cAAc,CAAC;AACtC,OAAO,EAAE,iBAAiB,EAAE,cAAc,EAAE,MAAM,uBAAuB,CAAC;AAE1E,eAAe;IACb,IAAI,IAAI;QACN,OAAO,kBAAkB,CAAC;IAC5B,CAAC;IACD,IAAI,SAAS;QACX,OAAO,MAAM,CAAC;IAChB,CAAC;IACD,IAAI,WAAW;QACb,OAAO,MAAM,CAAC;IAChB,CAAC;IACD,IAAI,cAAc;QAChB,OAAO,SAAS,CAAC;IACnB,CAAC;IACD,IAAI,eAAe;QACjB,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,KAAK,CAAC,aAAa,CACjB,OAAyB,EACzB,mBAA4B;QAE5B,IAAI,mBAAmB,EAAE;YACvB,MAAM,iBAAiB,CAAC,OAAO,CAAC,CAAC;SAClC;aAAM;YACL,MAAM,cAAc,CAAC,OAAO,CAAC,CAAC;SAC/B;QACD,OAAO,UAAU,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;IAC/C,CAAC;CACF,CAAC","sourcesContent":["import { AVPlaybackStatus } from './AV';\nimport ExponentAV from './ExponentAV';\nimport { requestFullscreen, exitFullscreen } from './FullscreenUtils.web';\n\nexport default {\n  get name(): string {\n    return 'ExpoVideoManager';\n  },\n  get ScaleNone(): string {\n    return 'none';\n  },\n  get ScaleToFill(): string {\n    return 'fill';\n  },\n  get ScaleAspectFit(): string {\n    return 'contain';\n  },\n  get ScaleAspectFill(): string {\n    return 'cover';\n  },\n\n  async setFullscreen(\n    element: HTMLMediaElement,\n    isFullScreenEnabled: boolean\n  ): Promise<AVPlaybackStatus> {\n    if (isFullScreenEnabled) {\n      await requestFullscreen(element);\n    } else {\n      await exitFullscreen(element);\n    }\n    return ExponentAV.getStatusForVideo(element);\n  },\n};\n"]}
\ No newline at end of file
+{"version":3,"file":"ExpoVideoManager.web.js","sourceRoot":"","sources":["../src/ExpoVideoManager.web.ts"],"names":[],"mappings":"AACA,OAAO,UAAU,MAAM,cAAc,CAAC;AACtC,OAAO,EAAE,iBAAiB,EAAE,cAAc,EAAE,MAAM,uBAAuB,CAAC;AAE1E,eAAe;IACb,IAAI,IAAI;QACN,OAAO,kBAAkB,CAAC;IAC5B,CAAC;IACD,IAAI,SAAS;QACX,OAAO,MAAM,CAAC;IAChB,CAAC;IACD,IAAI,WAAW;QACb,OAAO,MAAM,CAAC;IAChB,CAAC;IACD,IAAI,cAAc;QAChB,OAAO,SAAS,CAAC;IACnB,CAAC;IACD,IAAI,eAAe;QACjB,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,KAAK,CAAC,aAAa,CACjB,OAAyB,EACzB,mBAA4B;QAE5B,IAAI,mBAAmB,EAAE,CAAC;YACxB,MAAM,iBAAiB,CAAC,OAAO,CAAC,CAAC;QACnC,CAAC;aAAM,CAAC;YACN,MAAM,cAAc,CAAC,OAAO,CAAC,CAAC;QAChC,CAAC;QACD,OAAO,UAAU,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;IAC/C,CAAC;CACF,CAAC","sourcesContent":["import { AVPlaybackStatus } from './AV';\nimport ExponentAV from './ExponentAV';\nimport { requestFullscreen, exitFullscreen } from './FullscreenUtils.web';\n\nexport default {\n  get name(): string {\n    return 'ExpoVideoManager';\n  },\n  get ScaleNone(): string {\n    return 'none';\n  },\n  get ScaleToFill(): string {\n    return 'fill';\n  },\n  get ScaleAspectFit(): string {\n    return 'contain';\n  },\n  get ScaleAspectFill(): string {\n    return 'cover';\n  },\n\n  async setFullscreen(\n    element: HTMLMediaElement,\n    isFullScreenEnabled: boolean\n  ): Promise<AVPlaybackStatus> {\n    if (isFullScreenEnabled) {\n      await requestFullscreen(element);\n    } else {\n      await exitFullscreen(element);\n    }\n    return ExponentAV.getStatusForVideo(element);\n  },\n};\n"]}
\ No newline at end of file
diff --git a/build/ExponentAV.web.js b/build/ExponentAV.web.js
index 75b0b5f388add475c1f874f1d3b443cbaebb4e67..45658384dac788dd06beceac87333f3b2c833a46 100644
--- a/build/ExponentAV.web.js
+++ b/build/ExponentAV.web.js
@@ -56,7 +56,7 @@ function getStatusFromMedia(media) {
     const status = {
         isLoaded: true,
         uri: media.src,
-        progressUpdateIntervalMillis: 100,
+        progressUpdateIntervalMillis: 100, //TODO: Bacon: Add interval between calls
         durationMillis: media.duration * 1000,
         positionMillis: media.currentTime * 1000,
         // playableDurationMillis: media.buffered * 1000,
@@ -64,7 +64,7 @@ function getStatusFromMedia(media) {
         // seekMillisToleranceAfter?: number
         shouldPlay: media.autoplay,
         isPlaying,
-        isBuffering: false,
+        isBuffering: false, //media.waiting,
         rate: media.playbackRate,
         // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency
         shouldCorrectPitch: false,
@@ -94,7 +94,7 @@ async function setStatusForMedia(media, status) {
     // }
     if (status.shouldPlay !== undefined) {
         if (status.shouldPlay) {
-            await media.play();
+            await media.play().catch(console.warn);
         }
         else {
             await media.pause();
diff --git a/build/ExponentAV.web.js.map b/build/ExponentAV.web.js.map
index 4d80f204a8c43732eb7da44f2c3f0ec619a52285..58b34f6ad17d72caeac2dd7b67dc06b028ead345 100644
--- a/build/ExponentAV.web.js.map
+++ b/build/ExponentAV.web.js.map
@@ -1 +1 @@
-{"version":3,"file":"ExponentAV.web.js","sourceRoot":"","sources":["../src/ExponentAV.web.ts"],"names":[],"mappings":"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","sourcesContent":["import { PermissionResponse, PermissionStatus, SyntheticPlatformEmitter } from 'expo-modules-core';\n\nimport type { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV.types';\nimport type { RecordingStatus } from './Audio/Recording.types';\nimport { RecordingOptionsPresets } from './Audio/RecordingConstants';\n\nasync function getPermissionWithQueryAsync(\n  name: PermissionNameWithAdditionalValues\n): Promise<PermissionStatus | null> {\n  if (!navigator || !navigator.permissions || !navigator.permissions.query) return null;\n\n  try {\n    const { state } = await navigator.permissions.query({ name });\n    switch (state) {\n      case 'granted':\n        return PermissionStatus.GRANTED;\n      case 'denied':\n        return PermissionStatus.DENIED;\n      default:\n        return PermissionStatus.UNDETERMINED;\n    }\n  } catch {\n    // Firefox - TypeError: 'microphone' (value of 'name' member of PermissionDescriptor) is not a valid value for enumeration PermissionName.\n    return PermissionStatus.UNDETERMINED;\n  }\n}\n\nfunction getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n\n  // First get ahold of the legacy getUserMedia, if present\n  const getUserMedia =\n    // TODO: this method is deprecated, migrate to https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    navigator.getUserMedia ||\n    navigator.webkitGetUserMedia ||\n    navigator.mozGetUserMedia ||\n    function () {\n      const error: any = new Error('Permission unimplemented');\n      error.code = 0;\n      error.name = 'NotAllowedError';\n      throw error;\n    };\n\n  return new Promise((resolve, reject) => {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\n\nfunction getStatusFromMedia(media?: HTMLMediaElement): AVPlaybackStatus {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined,\n    };\n  }\n\n  const isPlaying = !!(\n    media.currentTime > 0 &&\n    !media.paused &&\n    !media.ended &&\n    media.readyState > 2\n  );\n\n  const status: AVPlaybackStatus = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100, //TODO: Bacon: Add interval between calls\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    // playableDurationMillis: media.buffered * 1000,\n    // seekMillisToleranceBefore?: number\n    // seekMillisToleranceAfter?: number\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false, //media.waiting,\n    rate: media.playbackRate,\n    // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    audioPan: 0,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended,\n  };\n\n  return status;\n}\n\nasync function setStatusForMedia(\n  media: HTMLMediaElement,\n  status: AVPlaybackStatusToSet\n): Promise<AVPlaybackStatus> {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  // if (status.progressUpdateIntervalMillis !== undefined) {\n  //   media.progressUpdateIntervalMillis = status.progressUpdateIntervalMillis;\n  // }\n  // if (status.seekMillisToleranceBefore !== undefined) {\n  //   media.seekMillisToleranceBefore = status.seekMillisToleranceBefore;\n  // }\n  // if (status.seekMillisToleranceAfter !== undefined) {\n  //   media.seekMillisToleranceAfter = status.seekMillisToleranceAfter;\n  // }\n  // if (status.shouldCorrectPitch !== undefined) {\n  //   media.shouldCorrectPitch = status.shouldCorrectPitch;\n  // }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      await media.play();\n    } else {\n      await media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nlet mediaRecorder: null | any /*MediaRecorder*/ = null;\nlet mediaRecorderUptimeOfLastStartResume: number = 0;\nlet mediaRecorderDurationAlreadyRecorded: number = 0;\nlet mediaRecorderIsRecording: boolean = false;\n\nfunction getAudioRecorderDurationMillis() {\n  let duration = mediaRecorderDurationAlreadyRecorded;\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n  return duration;\n}\n\nexport default {\n  get name(): string {\n    return 'ExponentAV';\n  },\n  async getStatusForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async loadForVideo(\n    element: HTMLMediaElement,\n    nativeSource: AVPlaybackNativeSource,\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async unloadForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async setStatusForVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replayVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  /* Audio */\n  async setAudioMode() {},\n  async setAudioIsEnabled() {},\n  async getStatusForSound(element: HTMLMediaElement) {\n    return getStatusFromMedia(element);\n  },\n  async loadForSound(\n    nativeSource: string | { uri: string; [key: string]: any },\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<[HTMLMediaElement, AVPlaybackStatus]> {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n\n    media.ontimeupdate = () => {\n      SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media),\n      });\n    };\n\n    media.onerror = () => {\n      SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error!.message,\n      });\n    };\n\n    const status = await setStatusForMedia(media, fullInitialStatus);\n\n    return [media, status];\n  },\n  async unloadForSound(element: HTMLMediaElement) {\n    element.pause();\n    element.removeAttribute('src');\n    element.load();\n    return getStatusFromMedia(element);\n  },\n  async setStatusForSound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replaySound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Recording */\n  //   async setUnloadedCallbackForAndroidRecording() {},\n  async getAudioRecordingStatus(): Promise<RecordingStatus> {\n    return {\n      canRecord: mediaRecorder?.state === 'recording' || mediaRecorder?.state === 'inactive',\n      isRecording: mediaRecorder?.state === 'recording',\n      isDoneRecording: false,\n      durationMillis: getAudioRecorderDurationMillis(),\n      uri: null,\n    };\n  },\n  async prepareAudioRecorder(options): Promise<{\n    uri: string | null;\n    // status is of type RecordingStatus, but without the canRecord field populated\n    status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n  }> {\n    if (typeof navigator !== 'undefined' && !navigator.mediaDevices) {\n      throw new Error('No media devices available');\n    }\n\n    mediaRecorderUptimeOfLastStartResume = 0;\n    mediaRecorderDurationAlreadyRecorded = 0;\n\n    const stream = await getUserMedia({ audio: true });\n\n    mediaRecorder = new (window as any).MediaRecorder(\n      stream,\n      options?.web || RecordingOptionsPresets.HIGH_QUALITY.web\n    );\n\n    mediaRecorder.addEventListener('pause', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n    });\n\n    mediaRecorder.addEventListener('resume', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('start', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderDurationAlreadyRecorded = 0;\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('stop', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n\n      // Clears recording icon in Chrome tab\n      stream.getTracks().forEach((track) => track.stop());\n    });\n\n    const { uri, ...status } = await this.getAudioRecordingStatus();\n\n    return { uri: null, status };\n  },\n  async startAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'paused') {\n      mediaRecorder.resume();\n    } else {\n      mediaRecorder.start();\n    }\n\n    return this.getAudioRecordingStatus();\n  },\n  async pauseAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    // Set status to paused\n    mediaRecorder.pause();\n\n    return this.getAudioRecordingStatus();\n  },\n  async stopAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'inactive') {\n      return this.getAudioRecordingStatus();\n    }\n\n    const dataPromise = new Promise<Blob>((resolve) =>\n      mediaRecorder.addEventListener('dataavailable', (e) => resolve(e.data))\n    );\n\n    mediaRecorder.stop();\n\n    const data = await dataPromise;\n    const url = URL.createObjectURL(data);\n\n    return {\n      ...(await this.getAudioRecordingStatus()),\n      uri: url,\n    };\n  },\n  async unloadAudioRecorder(): Promise<void> {\n    mediaRecorder = null;\n  },\n\n  async getPermissionsAsync(): Promise<PermissionResponse> {\n    const maybeStatus = await getPermissionWithQueryAsync('microphone');\n    switch (maybeStatus) {\n      case PermissionStatus.GRANTED:\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true,\n        };\n      case PermissionStatus.DENIED:\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false,\n        };\n      default:\n        return await this.requestPermissionsAsync();\n    }\n  },\n  async requestPermissionsAsync(): Promise<PermissionResponse> {\n    try {\n      const stream = await getUserMedia({ audio: true });\n      stream.getTracks().forEach((track) => track.stop());\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true,\n      };\n    } catch {\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n    }\n  },\n};\n"]}
\ No newline at end of file
+{"version":3,"file":"ExponentAV.web.js","sourceRoot":"","sources":["../src/ExponentAV.web.ts"],"names":[],"mappings":"AAAA,OAAO,EAAsB,gBAAgB,EAAE,wBAAwB,EAAE,MAAM,mBAAmB,CAAC;AAInG,OAAO,EAAE,uBAAuB,EAAE,MAAM,4BAA4B,CAAC;AAErE,KAAK,UAAU,2BAA2B,CACxC,IAAwC;IAExC,IAAI,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,WAAW,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,KAAK;QAAE,OAAO,IAAI,CAAC;IAEtF,IAAI,CAAC;QACH,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC;QAC9D,QAAQ,KAAK,EAAE,CAAC;YACd,KAAK,SAAS;gBACZ,OAAO,gBAAgB,CAAC,OAAO,CAAC;YAClC,KAAK,QAAQ;gBACX,OAAO,gBAAgB,CAAC,MAAM,CAAC;YACjC;gBACE,OAAO,gBAAgB,CAAC,YAAY,CAAC;QACzC,CAAC;IACH,CAAC;IAAC,MAAM,CAAC;QACP,0IAA0I;QAC1I,OAAO,gBAAgB,CAAC,YAAY,CAAC;IACvC,CAAC;AACH,CAAC;AAED,SAAS,YAAY,CAAC,WAAmC;IACvD,IAAI,SAAS,CAAC,YAAY,IAAI,SAAS,CAAC,YAAY,CAAC,YAAY,EAAE,CAAC;QAClE,OAAO,SAAS,CAAC,YAAY,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;IAC1D,CAAC;IAED,iFAAiF;IACjF,+DAA+D;IAC/D,oEAAoE;IAEpE,yDAAyD;IACzD,MAAM,YAAY;IAChB,yHAAyH;IACzH,SAAS,CAAC,YAAY;QACtB,SAAS,CAAC,kBAAkB;QAC5B,SAAS,CAAC,eAAe;QACzB;YACE,MAAM,KAAK,GAAQ,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;YACzD,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC;YACf,KAAK,CAAC,IAAI,GAAG,iBAAiB,CAAC;YAC/B,MAAM,KAAK,CAAC;QACd,CAAC,CAAC;IAEJ,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACrC,YAAY,CAAC,IAAI,CAAC,SAAS,EAAE,WAAW,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;IAC7D,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAS,kBAAkB,CAAC,KAAwB;IAClD,IAAI,CAAC,KAAK,EAAE,CAAC;QACX,OAAO;YACL,QAAQ,EAAE,KAAK;YACf,KAAK,EAAE,SAAS;SACjB,CAAC;IACJ,CAAC;IAED,MAAM,SAAS,GAAG,CAAC,CAAC,CAClB,KAAK,CAAC,WAAW,GAAG,CAAC;QACrB,CAAC,KAAK,CAAC,MAAM;QACb,CAAC,KAAK,CAAC,KAAK;QACZ,KAAK,CAAC,UAAU,GAAG,CAAC,CACrB,CAAC;IAEF,MAAM,MAAM,GAAqB;QAC/B,QAAQ,EAAE,IAAI;QACd,GAAG,EAAE,KAAK,CAAC,GAAG;QACd,4BAA4B,EAAE,GAAG,EAAE,yCAAyC;QAC5E,cAAc,EAAE,KAAK,CAAC,QAAQ,GAAG,IAAI;QACrC,cAAc,EAAE,KAAK,CAAC,WAAW,GAAG,IAAI;QACxC,iDAAiD;QACjD,qCAAqC;QACrC,oCAAoC;QACpC,UAAU,EAAE,KAAK,CAAC,QAAQ;QAC1B,SAAS;QACT,WAAW,EAAE,KAAK,EAAE,gBAAgB;QACpC,IAAI,EAAE,KAAK,CAAC,YAAY;QACxB,8HAA8H;QAC9H,kBAAkB,EAAE,KAAK;QACzB,MAAM,EAAE,KAAK,CAAC,MAAM;QACpB,QAAQ,EAAE,CAAC;QACX,OAAO,EAAE,KAAK,CAAC,KAAK;QACpB,SAAS,EAAE,KAAK,CAAC,IAAI;QACrB,aAAa,EAAE,KAAK,CAAC,KAAK;KAC3B,CAAC;IAEF,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,KAAK,UAAU,iBAAiB,CAC9B,KAAuB,EACvB,MAA6B;IAE7B,IAAI,MAAM,CAAC,cAAc,KAAK,SAAS,EAAE,CAAC;QACxC,KAAK,CAAC,WAAW,GAAG,MAAM,CAAC,cAAc,GAAG,IAAI,CAAC;IACnD,CAAC;IACD,2DAA2D;IAC3D,8EAA8E;IAC9E,IAAI;IACJ,wDAAwD;IACxD,wEAAwE;IACxE,IAAI;IACJ,uDAAuD;IACvD,sEAAsE;IACtE,IAAI;IACJ,iDAAiD;IACjD,0DAA0D;IAC1D,IAAI;IACJ,IAAI,MAAM,CAAC,UAAU,KAAK,SAAS,EAAE,CAAC;QACpC,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC;YACtB,MAAM,KAAK,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACzC,CAAC;aAAM,CAAC;YACN,MAAM,KAAK,CAAC,KAAK,EAAE,CAAC;QACtB,CAAC;IACH,CAAC;IACD,IAAI,MAAM,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;QAC9B,KAAK,CAAC,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC;IACnC,CAAC;IACD,IAAI,MAAM,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;QAChC,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;IAC/B,CAAC;IACD,IAAI,MAAM,CAAC,OAAO,KAAK,SAAS,EAAE,CAAC;QACjC,KAAK,CAAC,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC;IAC/B,CAAC;IACD,IAAI,MAAM,CAAC,SAAS,KAAK,SAAS,EAAE,CAAC;QACnC,KAAK,CAAC,IAAI,GAAG,MAAM,CAAC,SAAS,CAAC;IAChC,CAAC;IAED,OAAO,kBAAkB,CAAC,KAAK,CAAC,CAAC;AACnC,CAAC;AAED,IAAI,aAAa,CAAa,iBAAiB,GAAG,IAAI,CAAC;AACvD,IAAI,oCAAoC,GAAW,CAAC,CAAC;AACrD,IAAI,oCAAoC,GAAW,CAAC,CAAC;AACrD,IAAI,wBAAwB,GAAY,KAAK,CAAC;AAE9C,SAAS,8BAA8B;IACrC,IAAI,QAAQ,GAAG,oCAAoC,CAAC;IACpD,IAAI,wBAAwB,IAAI,oCAAoC,GAAG,CAAC,EAAE,CAAC;QACzE,QAAQ,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,oCAAoC,CAAC;IAChE,CAAC;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED,eAAe;IACb,IAAI,IAAI;QACN,OAAO,YAAY,CAAC;IACtB,CAAC;IACD,KAAK,CAAC,iBAAiB,CAAC,OAAyB;QAC/C,OAAO,kBAAkB,CAAC,OAAO,CAAC,CAAC;IACrC,CAAC;IACD,KAAK,CAAC,YAAY,CAChB,OAAyB,EACzB,YAAoC,EACpC,iBAAwC;QAExC,OAAO,kBAAkB,CAAC,OAAO,CAAC,CAAC;IACrC,CAAC;IACD,KAAK,CAAC,cAAc,CAAC,OAAyB;QAC5C,OAAO,kBAAkB,CAAC,OAAO,CAAC,CAAC;IACrC,CAAC;IACD,KAAK,CAAC,iBAAiB,CACrB,OAAyB,EACzB,MAA6B;QAE7B,OAAO,iBAAiB,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;IAC5C,CAAC;IACD,KAAK,CAAC,WAAW,CACf,OAAyB,EACzB,MAA6B;QAE7B,OAAO,iBAAiB,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;IAC5C,CAAC;IACD,WAAW;IACX,KAAK,CAAC,YAAY,KAAI,CAAC;IACvB,KAAK,CAAC,iBAAiB,KAAI,CAAC;IAC5B,KAAK,CAAC,iBAAiB,CAAC,OAAyB;QAC/C,OAAO,kBAAkB,CAAC,OAAO,CAAC,CAAC;IACrC,CAAC;IACD,KAAK,CAAC,YAAY,CAChB,YAA0D,EAC1D,iBAAwC;QAExC,MAAM,MAAM,GAAG,OAAO,YAAY,KAAK,QAAQ,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,GAAG,CAAC;QAClF,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC;QAEhC,KAAK,CAAC,YAAY,GAAG,GAAG,EAAE;YACxB,wBAAwB,CAAC,IAAI,CAAC,yBAAyB,EAAE;gBACvD,GAAG,EAAE,KAAK;gBACV,MAAM,EAAE,kBAAkB,CAAC,KAAK,CAAC;aAClC,CAAC,CAAC;QACL,CAAC,CAAC;QAEF,KAAK,CAAC,OAAO,GAAG,GAAG,EAAE;YACnB,wBAAwB,CAAC,IAAI,CAAC,oBAAoB,EAAE;gBAClD,GAAG,EAAE,KAAK;gBACV,KAAK,EAAE,KAAK,CAAC,KAAM,CAAC,OAAO;aAC5B,CAAC,CAAC;QACL,CAAC,CAAC;QAEF,MAAM,MAAM,GAAG,MAAM,iBAAiB,CAAC,KAAK,EAAE,iBAAiB,CAAC,CAAC;QAEjE,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IACzB,CAAC;IACD,KAAK,CAAC,cAAc,CAAC,OAAyB;QAC5C,OAAO,CAAC,KAAK,EAAE,CAAC;QAChB,OAAO,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;QAC/B,OAAO,CAAC,IAAI,EAAE,CAAC;QACf,OAAO,kBAAkB,CAAC,OAAO,CAAC,CAAC;IACrC,CAAC;IACD,KAAK,CAAC,iBAAiB,CACrB,OAAyB,EACzB,MAA6B;QAE7B,OAAO,iBAAiB,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;IAC5C,CAAC;IACD,KAAK,CAAC,WAAW,CACf,OAAyB,EACzB,MAA6B;QAE7B,OAAO,iBAAiB,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;IAC5C,CAAC;IAED,eAAe;IACf,uDAAuD;IACvD,KAAK,CAAC,uBAAuB;QAC3B,OAAO;YACL,SAAS,EAAE,aAAa,EAAE,KAAK,KAAK,WAAW,IAAI,aAAa,EAAE,KAAK,KAAK,UAAU;YACtF,WAAW,EAAE,aAAa,EAAE,KAAK,KAAK,WAAW;YACjD,eAAe,EAAE,KAAK;YACtB,cAAc,EAAE,8BAA8B,EAAE;YAChD,GAAG,EAAE,IAAI;SACV,CAAC;IACJ,CAAC;IACD,KAAK,CAAC,oBAAoB,CAAC,OAAO;QAKhC,IAAI,OAAO,SAAS,KAAK,WAAW,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,CAAC;YAChE,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;QAChD,CAAC;QAED,oCAAoC,GAAG,CAAC,CAAC;QACzC,oCAAoC,GAAG,CAAC,CAAC;QAEzC,MAAM,MAAM,GAAG,MAAM,YAAY,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;QAEnD,aAAa,GAAG,IAAK,MAAc,CAAC,aAAa,CAC/C,MAAM,EACN,OAAO,EAAE,GAAG,IAAI,uBAAuB,CAAC,YAAY,CAAC,GAAG,CACzD,CAAC;QAEF,aAAa,CAAC,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE;YAC3C,oCAAoC,GAAG,8BAA8B,EAAE,CAAC;YACxE,wBAAwB,GAAG,KAAK,CAAC;QACnC,CAAC,CAAC,CAAC;QAEH,aAAa,CAAC,gBAAgB,CAAC,QAAQ,EAAE,GAAG,EAAE;YAC5C,oCAAoC,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAClD,wBAAwB,GAAG,IAAI,CAAC;QAClC,CAAC,CAAC,CAAC;QAEH,aAAa,CAAC,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE;YAC3C,oCAAoC,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAClD,oCAAoC,GAAG,CAAC,CAAC;YACzC,wBAAwB,GAAG,IAAI,CAAC;QAClC,CAAC,CAAC,CAAC;QAEH,aAAa,CAAC,gBAAgB,CAAC,MAAM,EAAE,GAAG,EAAE;YAC1C,oCAAoC,GAAG,8BAA8B,EAAE,CAAC;YACxE,wBAAwB,GAAG,KAAK,CAAC;YAEjC,sCAAsC;YACtC,MAAM,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;QACtD,CAAC,CAAC,CAAC;QAEH,MAAM,EAAE,GAAG,EAAE,GAAG,MAAM,EAAE,GAAG,MAAM,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAEhE,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;IAC/B,CAAC;IACD,KAAK,CAAC,mBAAmB;QACvB,IAAI,aAAa,KAAK,IAAI,EAAE,CAAC;YAC3B,MAAM,IAAI,KAAK,CACb,iJAAiJ,CAClJ,CAAC;QACJ,CAAC;QAED,IAAI,aAAa,CAAC,KAAK,KAAK,QAAQ,EAAE,CAAC;YACrC,aAAa,CAAC,MAAM,EAAE,CAAC;QACzB,CAAC;aAAM,CAAC;YACN,aAAa,CAAC,KAAK,EAAE,CAAC;QACxB,CAAC;QAED,OAAO,IAAI,CAAC,uBAAuB,EAAE,CAAC;IACxC,CAAC;IACD,KAAK,CAAC,mBAAmB;QACvB,IAAI,aAAa,KAAK,IAAI,EAAE,CAAC;YAC3B,MAAM,IAAI,KAAK,CACb,iJAAiJ,CAClJ,CAAC;QACJ,CAAC;QAED,uBAAuB;QACvB,aAAa,CAAC,KAAK,EAAE,CAAC;QAEtB,OAAO,IAAI,CAAC,uBAAuB,EAAE,CAAC;IACxC,CAAC;IACD,KAAK,CAAC,kBAAkB;QACtB,IAAI,aAAa,KAAK,IAAI,EAAE,CAAC;YAC3B,MAAM,IAAI,KAAK,CACb,iJAAiJ,CAClJ,CAAC;QACJ,CAAC;QAED,IAAI,aAAa,CAAC,KAAK,KAAK,UAAU,EAAE,CAAC;YACvC,OAAO,IAAI,CAAC,uBAAuB,EAAE,CAAC;QACxC,CAAC;QAED,MAAM,WAAW,GAAG,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE,CAChD,aAAa,CAAC,gBAAgB,CAAC,eAAe,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CACxE,CAAC;QAEF,aAAa,CAAC,IAAI,EAAE,CAAC;QAErB,MAAM,IAAI,GAAG,MAAM,WAAW,CAAC;QAC/B,MAAM,GAAG,GAAG,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAEtC,OAAO;YACL,GAAG,CAAC,MAAM,IAAI,CAAC,uBAAuB,EAAE,CAAC;YACzC,GAAG,EAAE,GAAG;SACT,CAAC;IACJ,CAAC;IACD,KAAK,CAAC,mBAAmB;QACvB,aAAa,GAAG,IAAI,CAAC;IACvB,CAAC;IAED,KAAK,CAAC,mBAAmB;QACvB,MAAM,WAAW,GAAG,MAAM,2BAA2B,CAAC,YAAY,CAAC,CAAC;QACpE,QAAQ,WAAW,EAAE,CAAC;YACpB,KAAK,gBAAgB,CAAC,OAAO;gBAC3B,OAAO;oBACL,MAAM,EAAE,gBAAgB,CAAC,OAAO;oBAChC,OAAO,EAAE,OAAO;oBAChB,WAAW,EAAE,IAAI;oBACjB,OAAO,EAAE,IAAI;iBACd,CAAC;YACJ,KAAK,gBAAgB,CAAC,MAAM;gBAC1B,OAAO;oBACL,MAAM,EAAE,gBAAgB,CAAC,MAAM;oBAC/B,OAAO,EAAE,OAAO;oBAChB,WAAW,EAAE,IAAI;oBACjB,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ;gBACE,OAAO,MAAM,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAChD,CAAC;IACH,CAAC;IACD,KAAK,CAAC,uBAAuB;QAC3B,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,MAAM,YAAY,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;YACnD,MAAM,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;YACpD,OAAO;gBACL,MAAM,EAAE,gBAAgB,CAAC,OAAO;gBAChC,OAAO,EAAE,OAAO;gBAChB,WAAW,EAAE,IAAI;gBACjB,OAAO,EAAE,IAAI;aACd,CAAC;QACJ,CAAC;QAAC,MAAM,CAAC;YACP,OAAO;gBACL,MAAM,EAAE,gBAAgB,CAAC,MAAM;gBAC/B,OAAO,EAAE,OAAO;gBAChB,WAAW,EAAE,IAAI;gBACjB,OAAO,EAAE,KAAK;aACf,CAAC;QACJ,CAAC;IACH,CAAC;CACF,CAAC","sourcesContent":["import { PermissionResponse, PermissionStatus, SyntheticPlatformEmitter } from 'expo-modules-core';\n\nimport type { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV.types';\nimport type { RecordingStatus } from './Audio/Recording.types';\nimport { RecordingOptionsPresets } from './Audio/RecordingConstants';\n\nasync function getPermissionWithQueryAsync(\n  name: PermissionNameWithAdditionalValues\n): Promise<PermissionStatus | null> {\n  if (!navigator || !navigator.permissions || !navigator.permissions.query) return null;\n\n  try {\n    const { state } = await navigator.permissions.query({ name });\n    switch (state) {\n      case 'granted':\n        return PermissionStatus.GRANTED;\n      case 'denied':\n        return PermissionStatus.DENIED;\n      default:\n        return PermissionStatus.UNDETERMINED;\n    }\n  } catch {\n    // Firefox - TypeError: 'microphone' (value of 'name' member of PermissionDescriptor) is not a valid value for enumeration PermissionName.\n    return PermissionStatus.UNDETERMINED;\n  }\n}\n\nfunction getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n\n  // First get ahold of the legacy getUserMedia, if present\n  const getUserMedia =\n    // TODO: this method is deprecated, migrate to https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    navigator.getUserMedia ||\n    navigator.webkitGetUserMedia ||\n    navigator.mozGetUserMedia ||\n    function () {\n      const error: any = new Error('Permission unimplemented');\n      error.code = 0;\n      error.name = 'NotAllowedError';\n      throw error;\n    };\n\n  return new Promise((resolve, reject) => {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\n\nfunction getStatusFromMedia(media?: HTMLMediaElement): AVPlaybackStatus {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined,\n    };\n  }\n\n  const isPlaying = !!(\n    media.currentTime > 0 &&\n    !media.paused &&\n    !media.ended &&\n    media.readyState > 2\n  );\n\n  const status: AVPlaybackStatus = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100, //TODO: Bacon: Add interval between calls\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    // playableDurationMillis: media.buffered * 1000,\n    // seekMillisToleranceBefore?: number\n    // seekMillisToleranceAfter?: number\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false, //media.waiting,\n    rate: media.playbackRate,\n    // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    audioPan: 0,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended,\n  };\n\n  return status;\n}\n\nasync function setStatusForMedia(\n  media: HTMLMediaElement,\n  status: AVPlaybackStatusToSet\n): Promise<AVPlaybackStatus> {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  // if (status.progressUpdateIntervalMillis !== undefined) {\n  //   media.progressUpdateIntervalMillis = status.progressUpdateIntervalMillis;\n  // }\n  // if (status.seekMillisToleranceBefore !== undefined) {\n  //   media.seekMillisToleranceBefore = status.seekMillisToleranceBefore;\n  // }\n  // if (status.seekMillisToleranceAfter !== undefined) {\n  //   media.seekMillisToleranceAfter = status.seekMillisToleranceAfter;\n  // }\n  // if (status.shouldCorrectPitch !== undefined) {\n  //   media.shouldCorrectPitch = status.shouldCorrectPitch;\n  // }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      await media.play().catch(console.warn);\n    } else {\n      await media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nlet mediaRecorder: null | any /*MediaRecorder*/ = null;\nlet mediaRecorderUptimeOfLastStartResume: number = 0;\nlet mediaRecorderDurationAlreadyRecorded: number = 0;\nlet mediaRecorderIsRecording: boolean = false;\n\nfunction getAudioRecorderDurationMillis() {\n  let duration = mediaRecorderDurationAlreadyRecorded;\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n  return duration;\n}\n\nexport default {\n  get name(): string {\n    return 'ExponentAV';\n  },\n  async getStatusForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async loadForVideo(\n    element: HTMLMediaElement,\n    nativeSource: AVPlaybackNativeSource,\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async unloadForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async setStatusForVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replayVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  /* Audio */\n  async setAudioMode() {},\n  async setAudioIsEnabled() {},\n  async getStatusForSound(element: HTMLMediaElement) {\n    return getStatusFromMedia(element);\n  },\n  async loadForSound(\n    nativeSource: string | { uri: string; [key: string]: any },\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<[HTMLMediaElement, AVPlaybackStatus]> {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n\n    media.ontimeupdate = () => {\n      SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media),\n      });\n    };\n\n    media.onerror = () => {\n      SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error!.message,\n      });\n    };\n\n    const status = await setStatusForMedia(media, fullInitialStatus);\n\n    return [media, status];\n  },\n  async unloadForSound(element: HTMLMediaElement) {\n    element.pause();\n    element.removeAttribute('src');\n    element.load();\n    return getStatusFromMedia(element);\n  },\n  async setStatusForSound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replaySound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Recording */\n  //   async setUnloadedCallbackForAndroidRecording() {},\n  async getAudioRecordingStatus(): Promise<RecordingStatus> {\n    return {\n      canRecord: mediaRecorder?.state === 'recording' || mediaRecorder?.state === 'inactive',\n      isRecording: mediaRecorder?.state === 'recording',\n      isDoneRecording: false,\n      durationMillis: getAudioRecorderDurationMillis(),\n      uri: null,\n    };\n  },\n  async prepareAudioRecorder(options): Promise<{\n    uri: string | null;\n    // status is of type RecordingStatus, but without the canRecord field populated\n    status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n  }> {\n    if (typeof navigator !== 'undefined' && !navigator.mediaDevices) {\n      throw new Error('No media devices available');\n    }\n\n    mediaRecorderUptimeOfLastStartResume = 0;\n    mediaRecorderDurationAlreadyRecorded = 0;\n\n    const stream = await getUserMedia({ audio: true });\n\n    mediaRecorder = new (window as any).MediaRecorder(\n      stream,\n      options?.web || RecordingOptionsPresets.HIGH_QUALITY.web\n    );\n\n    mediaRecorder.addEventListener('pause', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n    });\n\n    mediaRecorder.addEventListener('resume', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('start', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderDurationAlreadyRecorded = 0;\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('stop', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n\n      // Clears recording icon in Chrome tab\n      stream.getTracks().forEach((track) => track.stop());\n    });\n\n    const { uri, ...status } = await this.getAudioRecordingStatus();\n\n    return { uri: null, status };\n  },\n  async startAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'paused') {\n      mediaRecorder.resume();\n    } else {\n      mediaRecorder.start();\n    }\n\n    return this.getAudioRecordingStatus();\n  },\n  async pauseAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    // Set status to paused\n    mediaRecorder.pause();\n\n    return this.getAudioRecordingStatus();\n  },\n  async stopAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'inactive') {\n      return this.getAudioRecordingStatus();\n    }\n\n    const dataPromise = new Promise<Blob>((resolve) =>\n      mediaRecorder.addEventListener('dataavailable', (e) => resolve(e.data))\n    );\n\n    mediaRecorder.stop();\n\n    const data = await dataPromise;\n    const url = URL.createObjectURL(data);\n\n    return {\n      ...(await this.getAudioRecordingStatus()),\n      uri: url,\n    };\n  },\n  async unloadAudioRecorder(): Promise<void> {\n    mediaRecorder = null;\n  },\n\n  async getPermissionsAsync(): Promise<PermissionResponse> {\n    const maybeStatus = await getPermissionWithQueryAsync('microphone');\n    switch (maybeStatus) {\n      case PermissionStatus.GRANTED:\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true,\n        };\n      case PermissionStatus.DENIED:\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false,\n        };\n      default:\n        return await this.requestPermissionsAsync();\n    }\n  },\n  async requestPermissionsAsync(): Promise<PermissionResponse> {\n    try {\n      const stream = await getUserMedia({ audio: true });\n      stream.getTracks().forEach((track) => track.stop());\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true,\n      };\n    } catch {\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n    }\n  },\n};\n"]}
\ No newline at end of file
diff --git a/build/ExponentVideo.d.ts b/build/ExponentVideo.d.ts
index d9e237834eee4e1baf4939d7801fb40443ce0d7b..1b92a2306a9ab513c5b6297eb85ba437652f6107 100644
--- a/build/ExponentVideo.d.ts
+++ b/build/ExponentVideo.d.ts
@@ -1,3 +1,3 @@
-declare const _default: import("react").ComponentType<any>;
+declare const _default: any;
 export default _default;
 //# sourceMappingURL=ExponentVideo.d.ts.map
\ No newline at end of file
diff --git a/build/ExponentVideo.web.d.ts b/build/ExponentVideo.web.d.ts
index 9853a8fcaefb975c9f3de70206e51bbcce869521..12934484fe91900f4ea4163ef0f299f55636d3f7 100644
--- a/build/ExponentVideo.web.d.ts
+++ b/build/ExponentVideo.web.d.ts
@@ -1,5 +1,6 @@
 import * as React from 'react';
 import { ViewProps } from 'react-native';
+import dashjs from 'dashjs';
 import { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV';
 import { VideoFullscreenUpdateEvent, VideoReadyForDisplayEvent } from './Video.types';
 type ExponentVideoProps = {
@@ -38,6 +39,7 @@ export type NaturalSize = {
 };
 export default class ExponentVideo extends React.Component<ExponentVideoProps> {
     _video?: HTMLVideoElement;
+    _dash?: dashjs.MediaPlayerClass;
     _removeFullscreenListener?: () => any;
     componentWillUnmount(): void;
     onFullscreenChange: (isFullscreen: boolean) => void;
@@ -52,7 +54,8 @@ export default class ExponentVideo extends React.Component<ExponentVideoProps> {
     onCanPlay: (event: any) => void;
     onStalled: () => void;
     onRef: (ref: HTMLVideoElement | null) => void;
-    render(): JSX.Element;
+    getURI(): string | undefined;
+    render(): React.JSX.Element;
 }
 export {};
 //# sourceMappingURL=ExponentVideo.web.d.ts.map
\ No newline at end of file
diff --git a/build/ExponentVideo.web.d.ts.map b/build/ExponentVideo.web.d.ts.map
index 36490c0f8f3b5eb3413c371ae2bc8d82b0818bd6..bc6ab3366d4f81a5f20b2eb7d952b63e887a0c4a 100644
--- a/build/ExponentVideo.web.d.ts.map
+++ b/build/ExponentVideo.web.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ExponentVideo.web.d.ts","sourceRoot":"","sources":["../src/ExponentVideo.web.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,SAAS,EAAE,MAAM,cAAc,CAAC;AAGzC,OAAO,EAAE,sBAAsB,EAAE,gBAAgB,EAAE,qBAAqB,EAAE,MAAM,MAAM,CAAC;AAGvF,OAAO,EAEL,0BAA0B,EAC1B,yBAAyB,EAC1B,MAAM,eAAe,CAAC;AAEvB,KAAK,kBAAkB,GAAG;IACxB,MAAM,EAAE,sBAAsB,GAAG,IAAI,CAAC;IACtC,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,MAAM,CAAC,EAAE,qBAAqB,CAAC;IAC/B,iBAAiB,CAAC,EAAE,OAAO,CAAC;IAC5B,cAAc,CAAC,EAAE,CAAC,KAAK,EAAE;QAAE,WAAW,EAAE,gBAAgB,CAAA;KAAE,KAAK,IAAI,CAAC;IACpE,iBAAiB,CAAC,EAAE,CAAC,KAAK,EAAE;QAAE,WAAW,EAAE,yBAAyB,CAAA;KAAE,KAAK,IAAI,CAAC;IAChF,kBAAkB,CAAC,EAAE,CAAC,KAAK,EAAE;QAAE,WAAW,EAAE,0BAA0B,CAAA;KAAE,KAAK,IAAI,CAAC;IAClF,WAAW,EAAE,MAAM,IAAI,CAAC;IACxB,MAAM,EAAE,CAAC,KAAK,EAAE;QAAE,WAAW,EAAE,gBAAgB,CAAA;KAAE,KAAK,IAAI,CAAC;IAC3D,OAAO,EAAE,CAAC,KAAK,EAAE;QAAE,WAAW,EAAE;YAAE,KAAK,EAAE,MAAM,CAAA;SAAE,CAAA;KAAE,KAAK,IAAI,CAAC;IAE7D,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB,GAAG,SAAS,CAAC;AAEd,MAAM,MAAM,WAAW,GAAG;IACxB,KAAK,EAAE,MAAM,CAAC;IACd,MAAM,EAAE,MAAM,CAAC;IACf,WAAW,EAAE,UAAU,GAAG,WAAW,CAAC;CACvC,CAAC;AAMF,MAAM,CAAC,OAAO,OAAO,aAAc,SAAQ,KAAK,CAAC,SAAS,CAAC,kBAAkB,CAAC;IAC5E,MAAM,CAAC,EAAE,gBAAgB,CAAC;IAC1B,yBAAyB,CAAC,EAAE,MAAM,GAAG,CAAC;IAEtC,oBAAoB;IAIpB,kBAAkB,iBAAkB,OAAO,UAWzC;IAEF,cAAc,sBAMZ;IAEF,WAAW,aAMT;IAEF,YAAY,uBAMV;IAEF,OAAO,uBAML;IAEF,UAAU,aAER;IAEF,SAAS,aAEP;IAEF,OAAO,aAEL;IAEF,gBAAgB,aAEd;IAEF,SAAS,uBAMP;IAEF,SAAS,aAEP;IAEF,KAAK,QAAS,gBAAgB,GAAG,IAAI,UASnC;IAEF,MAAM;CA8BP"}
\ No newline at end of file
+{"version":3,"file":"ExponentVideo.web.d.ts","sourceRoot":"","sources":["../src/ExponentVideo.web.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,SAAS,EAAE,MAAM,cAAc,CAAC;AAEzC,OAAO,MAAM,MAAM,QAAQ,CAAC;AAE5B,OAAO,EAAE,sBAAsB,EAAE,gBAAgB,EAAE,qBAAqB,EAAE,MAAM,MAAM,CAAC;AAGvF,OAAO,EAEL,0BAA0B,EAC1B,yBAAyB,EAC1B,MAAM,eAAe,CAAC;AAEvB,KAAK,kBAAkB,GAAG;IACxB,MAAM,EAAE,sBAAsB,GAAG,IAAI,CAAC;IACtC,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,MAAM,CAAC,EAAE,qBAAqB,CAAC;IAC/B,iBAAiB,CAAC,EAAE,OAAO,CAAC;IAC5B,cAAc,CAAC,EAAE,CAAC,KAAK,EAAE;QAAE,WAAW,EAAE,gBAAgB,CAAA;KAAE,KAAK,IAAI,CAAC;IACpE,iBAAiB,CAAC,EAAE,CAAC,KAAK,EAAE;QAAE,WAAW,EAAE,yBAAyB,CAAA;KAAE,KAAK,IAAI,CAAC;IAChF,kBAAkB,CAAC,EAAE,CAAC,KAAK,EAAE;QAAE,WAAW,EAAE,0BAA0B,CAAA;KAAE,KAAK,IAAI,CAAC;IAClF,WAAW,EAAE,MAAM,IAAI,CAAC;IACxB,MAAM,EAAE,CAAC,KAAK,EAAE;QAAE,WAAW,EAAE,gBAAgB,CAAA;KAAE,KAAK,IAAI,CAAC;IAC3D,OAAO,EAAE,CAAC,KAAK,EAAE;QAAE,WAAW,EAAE;YAAE,KAAK,EAAE,MAAM,CAAA;SAAE,CAAA;KAAE,KAAK,IAAI,CAAC;IAE7D,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB,GAAG,SAAS,CAAC;AAEd,MAAM,MAAM,WAAW,GAAG;IACxB,KAAK,EAAE,MAAM,CAAC;IACd,MAAM,EAAE,MAAM,CAAC;IACf,WAAW,EAAE,UAAU,GAAG,WAAW,CAAC;CACvC,CAAC;AAUF,MAAM,CAAC,OAAO,OAAO,aAAc,SAAQ,KAAK,CAAC,SAAS,CAAC,kBAAkB,CAAC;IAC5E,MAAM,CAAC,EAAE,gBAAgB,CAAC;IAC1B,KAAK,CAAC,EAAE,MAAM,CAAC,gBAAgB,CAAC;IAChC,yBAAyB,CAAC,EAAE,MAAM,GAAG,CAAC;IAEtC,oBAAoB;IAIpB,kBAAkB,iBAAkB,OAAO,UAWzC;IAEF,cAAc,sBAMZ;IAEF,WAAW,aAMT;IAEF,YAAY,uBAMV;IAEF,OAAO,uBAML;IAEF,UAAU,aAER;IAEF,SAAS,aAEP;IAEF,OAAO,aAEL;IAEF,gBAAgB,aAEd;IAEF,SAAS,uBAMP;IAEF,SAAS,aAEP;IAEF,KAAK,QAAS,gBAAgB,GAAG,IAAI,UAqBnC;IAEF,MAAM,IAAI,MAAM,GAAG,SAAS;IAgB5B,MAAM;CAkCP"}
\ No newline at end of file
diff --git a/build/ExponentVideo.web.js b/build/ExponentVideo.web.js
index b7ecf1dd60f7a157aa62e01e44cc602fe8113de8..efcb532447f2593e8e9831f488f50b7013524e76 100644
--- a/build/ExponentVideo.web.js
+++ b/build/ExponentVideo.web.js
@@ -1,11 +1,14 @@
 import * as React from 'react';
 import createElement from 'react-native-web/dist/exports/createElement';
+import dashjs from 'dashjs';
 import ExponentAV from './ExponentAV';
 import { addFullscreenListener } from './FullscreenUtils.web';
 import { VideoFullscreenUpdate, } from './Video.types';
 const Video = React.forwardRef((props, ref) => createElement('video', { ...props, ref }));
+const Source = React.forwardRef((props, ref) => createElement('source', { ...props, ref }));
 export default class ExponentVideo extends React.Component {
     _video;
+    _dash;
     _removeFullscreenListener;
     componentWillUnmount() {
         this._removeFullscreenListener?.();
@@ -78,6 +81,18 @@ export default class ExponentVideo extends React.Component {
         this._removeFullscreenListener?.();
         if (ref) {
             this._video = ref;
+            const uri = this.getURI();
+            if (uri?.endsWith('.mpd')) {
+                try {
+                    const dash = dashjs.MediaPlayer().create();
+                    dash.initialize(this._video, uri, this.props.status?.shouldPlay || false);
+                    dash.attachView(this._video);
+                    this._dash = dash;
+                }
+                catch (e) {
+                    console.error(e);
+                }
+            }
             this._removeFullscreenListener = addFullscreenListener(this._video, this.onFullscreenChange);
             this.onStatusUpdate();
         }
@@ -85,6 +100,19 @@ export default class ExponentVideo extends React.Component {
             this._removeFullscreenListener = undefined;
         }
     };
+    getURI() {
+        let uri = this.props.source?.uri;
+        if (!uri) {
+            return undefined;
+        }
+        if (uri.endsWith('.mpd')) {
+            const isIOS = /AppleWebKit/.test(navigator.userAgent) && /iPad|iPhone|iPod/.test(navigator.userAgent);
+            if (isIOS) {
+                uri = uri.replace('.mpd', '.m3u8');
+            }
+        }
+        return uri;
+    }
     render() {
         const { source, status = {}, resizeMode: objectFit, useNativeControls, style } = this.props;
         const customStyle = {
@@ -92,7 +120,8 @@ export default class ExponentVideo extends React.Component {
             objectFit,
             overflow: 'hidden',
         };
-        return (<Video ref={this.onRef} onLoadStart={this.onLoadStart} onLoadedData={this.onLoadedData} onError={this.onError} onTimeUpdate={this.onProgress} onSeeking={this.onSeeking} onEnded={this.onEnded} onLoadedMetadata={this.onLoadedMetadata} onCanPlay={this.onCanPlay} onStalled={this.onStalled} src={source?.uri || undefined} muted={status.isMuted} loop={status.isLooping} autoPlay={status.shouldPlay} controls={useNativeControls} style={[style, customStyle]} playsInline/>);
+        const uri = this.getURI();
+        return (React.createElement(Video, { ref: this.onRef, onLoadStart: this.onLoadStart, onLoadedData: this.onLoadedData, onError: this.onError, onTimeUpdate: this.onProgress, onSeeking: this.onSeeking, onEnded: this.onEnded, onLoadedMetadata: this.onLoadedMetadata, onCanPlay: this.onCanPlay, onStalled: this.onStalled, src: uri, muted: status.isMuted, loop: status.isLooping, autoPlay: status.shouldPlay, controls: useNativeControls, style: [style, customStyle], playsInline: true }));
     }
 }
 //# sourceMappingURL=ExponentVideo.web.js.map
\ No newline at end of file
diff --git a/build/ExponentVideo.web.js.map b/build/ExponentVideo.web.js.map
index eaac41b3f2806b2ee67f5bf4cbf49b073d3f3ad7..d1638f74752695d18ff23d4b2c647a2d5f34aeea 100644
--- a/build/ExponentVideo.web.js.map
+++ b/build/ExponentVideo.web.js.map
@@ -1 +1 @@
-{"version":3,"file":"ExponentVideo.web.js","sourceRoot":"","sources":["../src/ExponentVideo.web.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { ViewProps } from 'react-native';\nimport createElement from 'react-native-web/dist/exports/createElement';\n\nimport { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV';\nimport ExponentAV from './ExponentAV';\nimport { addFullscreenListener } from './FullscreenUtils.web';\nimport {\n  VideoFullscreenUpdate,\n  VideoFullscreenUpdateEvent,\n  VideoReadyForDisplayEvent,\n} from './Video.types';\n\ntype ExponentVideoProps = {\n  source: AVPlaybackNativeSource | null;\n  resizeMode?: object;\n  status?: AVPlaybackStatusToSet;\n  useNativeControls?: boolean;\n  onStatusUpdate?: (event: { nativeEvent: AVPlaybackStatus }) => void;\n  onReadyForDisplay?: (event: { nativeEvent: VideoReadyForDisplayEvent }) => void;\n  onFullscreenUpdate?: (event: { nativeEvent: VideoFullscreenUpdateEvent }) => void;\n  onLoadStart: () => void;\n  onLoad: (event: { nativeEvent: AVPlaybackStatus }) => void;\n  onError: (event: { nativeEvent: { error: string } }) => void;\n  // Required by react-native\n  scaleX?: number;\n  scaleY?: number;\n  translateX?: number;\n  translateY?: number;\n  rotation?: number;\n} & ViewProps;\n\nexport type NaturalSize = {\n  width: number;\n  height: number;\n  orientation: 'portrait' | 'landscape';\n};\n\nconst Video: any = React.forwardRef<HTMLVideoElement, ExponentVideoProps>((props, ref) =>\n  createElement('video', { ...props, ref })\n);\n\nexport default class ExponentVideo extends React.Component<ExponentVideoProps> {\n  _video?: HTMLVideoElement;\n  _removeFullscreenListener?: () => any;\n\n  componentWillUnmount() {\n    this._removeFullscreenListener?.();\n  }\n\n  onFullscreenChange = (isFullscreen: boolean) => {\n    if (!this.props.onFullscreenUpdate) return;\n    if (isFullscreen) {\n      this.props.onFullscreenUpdate({\n        nativeEvent: { fullscreenUpdate: VideoFullscreenUpdate.PLAYER_DID_PRESENT },\n      });\n    } else {\n      this.props.onFullscreenUpdate({\n        nativeEvent: { fullscreenUpdate: VideoFullscreenUpdate.PLAYER_DID_DISMISS },\n      });\n    }\n  };\n\n  onStatusUpdate = async () => {\n    if (!this.props.onStatusUpdate) {\n      return;\n    }\n    const nativeEvent = await ExponentAV.getStatusForVideo(this._video);\n    this.props.onStatusUpdate({ nativeEvent });\n  };\n\n  onLoadStart = () => {\n    if (!this.props.onLoadStart) {\n      return;\n    }\n    this.props.onLoadStart();\n    this.onStatusUpdate();\n  };\n\n  onLoadedData = (event) => {\n    if (!this.props.onLoad) {\n      return;\n    }\n    this.props.onLoad(event);\n    this.onStatusUpdate();\n  };\n\n  onError = (event) => {\n    if (!this.props.onError) {\n      return;\n    }\n    this.props.onError(event);\n    this.onStatusUpdate();\n  };\n\n  onProgress = () => {\n    this.onStatusUpdate();\n  };\n\n  onSeeking = () => {\n    this.onStatusUpdate();\n  };\n\n  onEnded = () => {\n    this.onStatusUpdate();\n  };\n\n  onLoadedMetadata = () => {\n    this.onStatusUpdate();\n  };\n\n  onCanPlay = (event) => {\n    if (!this.props.onReadyForDisplay) {\n      return;\n    }\n    this.props.onReadyForDisplay(event);\n    this.onStatusUpdate();\n  };\n\n  onStalled = () => {\n    this.onStatusUpdate();\n  };\n\n  onRef = (ref: HTMLVideoElement | null) => {\n    this._removeFullscreenListener?.();\n    if (ref) {\n      this._video = ref;\n      this._removeFullscreenListener = addFullscreenListener(this._video, this.onFullscreenChange);\n      this.onStatusUpdate();\n    } else {\n      this._removeFullscreenListener = undefined;\n    }\n  };\n\n  render() {\n    const { source, status = {}, resizeMode: objectFit, useNativeControls, style } = this.props;\n\n    const customStyle = {\n      position: undefined,\n      objectFit,\n      overflow: 'hidden',\n    };\n    return (\n      <Video\n        ref={this.onRef}\n        onLoadStart={this.onLoadStart}\n        onLoadedData={this.onLoadedData}\n        onError={this.onError}\n        onTimeUpdate={this.onProgress}\n        onSeeking={this.onSeeking}\n        onEnded={this.onEnded}\n        onLoadedMetadata={this.onLoadedMetadata}\n        onCanPlay={this.onCanPlay}\n        onStalled={this.onStalled}\n        src={source?.uri || undefined}\n        muted={status.isMuted}\n        loop={status.isLooping}\n        autoPlay={status.shouldPlay}\n        controls={useNativeControls}\n        style={[style, customStyle]}\n        playsInline\n      />\n    );\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ExponentVideo.web.js","sourceRoot":"","sources":["../src/ExponentVideo.web.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { ViewProps } from 'react-native';\nimport createElement from 'react-native-web/dist/exports/createElement';\nimport dashjs from 'dashjs';\n\nimport { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV';\nimport ExponentAV from './ExponentAV';\nimport { addFullscreenListener } from './FullscreenUtils.web';\nimport {\n  VideoFullscreenUpdate,\n  VideoFullscreenUpdateEvent,\n  VideoReadyForDisplayEvent,\n} from './Video.types';\n\ntype ExponentVideoProps = {\n  source: AVPlaybackNativeSource | null;\n  resizeMode?: object;\n  status?: AVPlaybackStatusToSet;\n  useNativeControls?: boolean;\n  onStatusUpdate?: (event: { nativeEvent: AVPlaybackStatus }) => void;\n  onReadyForDisplay?: (event: { nativeEvent: VideoReadyForDisplayEvent }) => void;\n  onFullscreenUpdate?: (event: { nativeEvent: VideoFullscreenUpdateEvent }) => void;\n  onLoadStart: () => void;\n  onLoad: (event: { nativeEvent: AVPlaybackStatus }) => void;\n  onError: (event: { nativeEvent: { error: string } }) => void;\n  // Required by react-native\n  scaleX?: number;\n  scaleY?: number;\n  translateX?: number;\n  translateY?: number;\n  rotation?: number;\n} & ViewProps;\n\nexport type NaturalSize = {\n  width: number;\n  height: number;\n  orientation: 'portrait' | 'landscape';\n};\n\nconst Video: any = React.forwardRef<HTMLVideoElement, ExponentVideoProps>((props, ref) =>\n  createElement('video', { ...props, ref })\n);\n\nconst Source: any = React.forwardRef<HTMLSourceElement, { src: string }>((props, ref) =>\n  createElement('source', { ...props, ref })\n);\n\nexport default class ExponentVideo extends React.Component<ExponentVideoProps> {\n  _video?: HTMLVideoElement;\n  _dash?: dashjs.MediaPlayerClass;\n  _removeFullscreenListener?: () => any;\n\n  componentWillUnmount() {\n    this._removeFullscreenListener?.();\n  }\n\n  onFullscreenChange = (isFullscreen: boolean) => {\n    if (!this.props.onFullscreenUpdate) return;\n    if (isFullscreen) {\n      this.props.onFullscreenUpdate({\n        nativeEvent: { fullscreenUpdate: VideoFullscreenUpdate.PLAYER_DID_PRESENT },\n      });\n    } else {\n      this.props.onFullscreenUpdate({\n        nativeEvent: { fullscreenUpdate: VideoFullscreenUpdate.PLAYER_DID_DISMISS },\n      });\n    }\n  };\n\n  onStatusUpdate = async () => {\n    if (!this.props.onStatusUpdate) {\n      return;\n    }\n    const nativeEvent = await ExponentAV.getStatusForVideo(this._video);\n    this.props.onStatusUpdate({ nativeEvent });\n  };\n\n  onLoadStart = () => {\n    if (!this.props.onLoadStart) {\n      return;\n    }\n    this.props.onLoadStart();\n    this.onStatusUpdate();\n  };\n\n  onLoadedData = (event) => {\n    if (!this.props.onLoad) {\n      return;\n    }\n    this.props.onLoad(event);\n    this.onStatusUpdate();\n  };\n\n  onError = (event) => {\n    if (!this.props.onError) {\n      return;\n    }\n    this.props.onError(event);\n    this.onStatusUpdate();\n  };\n\n  onProgress = () => {\n    this.onStatusUpdate();\n  };\n\n  onSeeking = () => {\n    this.onStatusUpdate();\n  };\n\n  onEnded = () => {\n    this.onStatusUpdate();\n  };\n\n  onLoadedMetadata = () => {\n    this.onStatusUpdate();\n  };\n\n  onCanPlay = (event) => {\n    if (!this.props.onReadyForDisplay) {\n      return;\n    }\n    this.props.onReadyForDisplay(event);\n    this.onStatusUpdate();\n  };\n\n  onStalled = () => {\n    this.onStatusUpdate();\n  };\n\n  onRef = (ref: HTMLVideoElement | null) => {\n    this._removeFullscreenListener?.();\n    if (ref) {\n      this._video = ref;\n      const uri = this.getURI();\n      if (uri?.endsWith('.mpd')) {\n        try {\n          const dash = dashjs.MediaPlayer().create();\n          dash.initialize(this._video, uri, this.props.status?.shouldPlay || false);\n          dash.attachView(this._video);\n\n          this._dash = dash;\n        } catch (e) {\n          console.error(e);\n        }\n      }\n      this._removeFullscreenListener = addFullscreenListener(this._video, this.onFullscreenChange);\n      this.onStatusUpdate();\n    } else {\n      this._removeFullscreenListener = undefined;\n    }\n  };\n\n  getURI(): string | undefined {\n    let uri = this.props.source?.uri;\n    if (!uri) {\n      return undefined;\n    }\n\n    if (uri.endsWith('.mpd')) {\n      const isIOS = /AppleWebKit/.test(navigator.userAgent) && /iPad|iPhone|iPod/.test(navigator.userAgent);\n      if (isIOS) {\n        uri = uri.replace('.mpd', '.m3u8');\n      }\n    }\n\n    return uri;\n  }\n\n  render() {\n    const { source, status = {}, resizeMode: objectFit, useNativeControls, style } = this.props;\n\n    const customStyle = {\n      position: undefined,\n      objectFit,\n      overflow: 'hidden',\n    };\n\n    const uri = this.getURI();\n\n    return (\n      <Video\n        ref={this.onRef}\n        onLoadStart={this.onLoadStart}\n        onLoadedData={this.onLoadedData}\n        onError={this.onError}\n        onTimeUpdate={this.onProgress}\n        onSeeking={this.onSeeking}\n        onEnded={this.onEnded}\n        onLoadedMetadata={this.onLoadedMetadata}\n        onCanPlay={this.onCanPlay}\n        onStalled={this.onStalled}\n        src={uri}\n        muted={status.isMuted}\n        loop={status.isLooping}\n        autoPlay={status.shouldPlay}\n        controls={useNativeControls}\n        style={[style, customStyle]}\n        playsInline\n      >\n\t  </Video>\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/build/FullscreenUtils.web.js.map b/build/FullscreenUtils.web.js.map
index 84c0b133ec8b7d941240339f02b438e4efedf687..0a33b82ac5ba95ee1e8f54a2dfa10984812e8806 100644
--- a/build/FullscreenUtils.web.js.map
+++ b/build/FullscreenUtils.web.js.map
@@ -1 +1 @@
-{"version":3,"file":"FullscreenUtils.web.js","sourceRoot":"","sources":["../src/FullscreenUtils.web.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Detect if the browser supports the standard fullscreen API on the given\n * element:\n * https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API\n */\nconst supportsFullscreenAPI = (element: HTMLMediaElement): boolean =>\n  'requestFullscreen' in element;\n\n/**\n * Detect if the browser supports the non-standard webkit fullscreen API on the\n * given element (looking at you, Safari).\n */\nconst supportsWebkitFullscreenAPI = (element: HTMLMediaElement): boolean =>\n  'webkitEnterFullScreen' in element;\n\n/**\n * Detect if the browser supports the non-standard ms fullscreen API on the\n * given element (looking at you, IE11).\n */\nconst supportsMsFullscreenAPI = (element: HTMLMediaElement): boolean =>\n  'msRequestFullscreen' in element;\n\n/**\n * Detect if the browser supports the `webkitFullscreenChange` event. This is\n * a non-standard event added to Safari on macOS by Apple:\n * https://developer.apple.com/documentation/webkitjs/document/1631998-onwebkitfullscreenchange\n */\nconst supportsWebkitFullscreenChangeEvent = (): boolean =>\n  supportsEvent('video', 'webkitfullscreenchange');\n\n/**\n * A helper that adds an event listener to an element. The key value-add over\n * the native addEventListener is that it returns a function that will remove\n * the event listener. This allows the setup and teardown logic for a listener\n * to be easily colocated.\n */\nfunction addEventListener(\n  element: Document | HTMLElement,\n  eventName: string,\n  listener: EventListenerOrEventListenerObject\n): () => any {\n  element.addEventListener(eventName, listener);\n  return () => element.removeEventListener(eventName, listener);\n}\n\n/**\n * Detect if the browser supports an event on a particular element type.\n */\nconst supportsEvent = (elementName: string, eventName: string): boolean => {\n  // Detect if the browser supports the event by attempting to add a handler\n  // attribute for that event to the provided element. If the event is supported\n  // then the browser will accept the attribute and report the type of the\n  // attribute as \"function\". See: https://stackoverflow.com/a/4562426/2747759\n  const element = document.createElement(elementName);\n  element.setAttribute('on' + eventName, 'return;');\n  return typeof element['on' + eventName] === 'function';\n};\n\n/**\n * Switches a video element into fullscreen.\n */\nexport async function requestFullscreen(element: HTMLMediaElement): Promise<void> {\n  if (supportsFullscreenAPI(element)) {\n    return element.requestFullscreen();\n  } else if (supportsWebkitFullscreenAPI(element)) {\n    // This API is synchronous so no need to return the result\n    element['webkitEnterFullScreen']?.();\n  } else if (supportsMsFullscreenAPI(element)) {\n    // This API is synchronous so no need to return the result\n    element['msRequestFullscreen']?.();\n  } else {\n    throw new Error('Fullscreen not supported');\n  }\n}\n\n/**\n * Switches a video element out of fullscreen.\n */\n\nexport async function exitFullscreen(element: HTMLMediaElement): Promise<void> {\n  if (supportsFullscreenAPI(element)) {\n    return document.exitFullscreen();\n  } else if (supportsWebkitFullscreenAPI(element)) {\n    // This API is synchronous so no need to return the result\n    element['webkitExitFullScreen']?.();\n  } else if (supportsMsFullscreenAPI(element)) {\n    // This API is synchronous so no need to return the result\n    document['msExitFullscreen']?.();\n  } else {\n    throw new Error('Fullscreen not supported');\n  }\n}\n\n/**\n * Listens for fullscreen change events on a video element. The provided\n * callback will be called with `true` when the video is switched into\n * fullscreen and `false` when the video is switched out of fullscreen.\n */\nexport function addFullscreenListener(\n  element: HTMLVideoElement,\n  callback: (isFullscreen: boolean) => void\n): () => any {\n  if (supportsFullscreenAPI(element)) {\n    // Used by browsers that support the official spec\n    return addEventListener(element, 'fullscreenchange', (event) =>\n      callback(document.fullscreenElement === event.target)\n    );\n  } else if (supportsWebkitFullscreenAPI(element) && supportsWebkitFullscreenChangeEvent()) {\n    // Used by Safari on macOS\n    return addEventListener(element, 'webkitfullscreenchange', (event) =>\n      callback(document['webkitFullscreenElement'] === event.target)\n    );\n  } else if (supportsWebkitFullscreenAPI(element)) {\n    // Used by Safari on iOS\n    const removeBeginListener = addEventListener(element, 'webkitbeginfullscreen', () =>\n      callback(true)\n    );\n    const removeEndListener = addEventListener(element, 'webkitendfullscreen', () =>\n      callback(false)\n    );\n    return () => {\n      removeBeginListener();\n      removeEndListener();\n    };\n  } else if (supportsMsFullscreenAPI(element)) {\n    // Used by IE11\n    return addEventListener(document, 'MSFullscreenChange', (event) =>\n      callback(document['msFullscreenElement'] === event.target)\n    );\n  } else {\n    return () => {};\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"FullscreenUtils.web.js","sourceRoot":"","sources":["../src/FullscreenUtils.web.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AACH,MAAM,qBAAqB,GAAG,CAAC,OAAyB,EAAW,EAAE,CACnE,mBAAmB,IAAI,OAAO,CAAC;AAEjC;;;GAGG;AACH,MAAM,2BAA2B,GAAG,CAAC,OAAyB,EAAW,EAAE,CACzE,uBAAuB,IAAI,OAAO,CAAC;AAErC;;;GAGG;AACH,MAAM,uBAAuB,GAAG,CAAC,OAAyB,EAAW,EAAE,CACrE,qBAAqB,IAAI,OAAO,CAAC;AAEnC;;;;GAIG;AACH,MAAM,mCAAmC,GAAG,GAAY,EAAE,CACxD,aAAa,CAAC,OAAO,EAAE,wBAAwB,CAAC,CAAC;AAEnD;;;;;GAKG;AACH,SAAS,gBAAgB,CACvB,OAA+B,EAC/B,SAAiB,EACjB,QAA4C;IAE5C,OAAO,CAAC,gBAAgB,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;IAC9C,OAAO,GAAG,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;AAChE,CAAC;AAED;;GAEG;AACH,MAAM,aAAa,GAAG,CAAC,WAAmB,EAAE,SAAiB,EAAW,EAAE;IACxE,0EAA0E;IAC1E,8EAA8E;IAC9E,wEAAwE;IACxE,4EAA4E;IAC5E,MAAM,OAAO,GAAG,QAAQ,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;IACpD,OAAO,CAAC,YAAY,CAAC,IAAI,GAAG,SAAS,EAAE,SAAS,CAAC,CAAC;IAClD,OAAO,OAAO,OAAO,CAAC,IAAI,GAAG,SAAS,CAAC,KAAK,UAAU,CAAC;AACzD,CAAC,CAAC;AAEF;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,iBAAiB,CAAC,OAAyB;IAC/D,IAAI,qBAAqB,CAAC,OAAO,CAAC,EAAE,CAAC;QACnC,OAAO,OAAO,CAAC,iBAAiB,EAAE,CAAC;IACrC,CAAC;SAAM,IAAI,2BAA2B,CAAC,OAAO,CAAC,EAAE,CAAC;QAChD,0DAA0D;QAC1D,OAAO,CAAC,uBAAuB,CAAC,EAAE,EAAE,CAAC;IACvC,CAAC;SAAM,IAAI,uBAAuB,CAAC,OAAO,CAAC,EAAE,CAAC;QAC5C,0DAA0D;QAC1D,OAAO,CAAC,qBAAqB,CAAC,EAAE,EAAE,CAAC;IACrC,CAAC;SAAM,CAAC;QACN,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;IAC9C,CAAC;AACH,CAAC;AAED;;GAEG;AAEH,MAAM,CAAC,KAAK,UAAU,cAAc,CAAC,OAAyB;IAC5D,IAAI,qBAAqB,CAAC,OAAO,CAAC,EAAE,CAAC;QACnC,OAAO,QAAQ,CAAC,cAAc,EAAE,CAAC;IACnC,CAAC;SAAM,IAAI,2BAA2B,CAAC,OAAO,CAAC,EAAE,CAAC;QAChD,0DAA0D;QAC1D,OAAO,CAAC,sBAAsB,CAAC,EAAE,EAAE,CAAC;IACtC,CAAC;SAAM,IAAI,uBAAuB,CAAC,OAAO,CAAC,EAAE,CAAC;QAC5C,0DAA0D;QAC1D,QAAQ,CAAC,kBAAkB,CAAC,EAAE,EAAE,CAAC;IACnC,CAAC;SAAM,CAAC;QACN,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;IAC9C,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,qBAAqB,CACnC,OAAyB,EACzB,QAAyC;IAEzC,IAAI,qBAAqB,CAAC,OAAO,CAAC,EAAE,CAAC;QACnC,kDAAkD;QAClD,OAAO,gBAAgB,CAAC,OAAO,EAAE,kBAAkB,EAAE,CAAC,KAAK,EAAE,EAAE,CAC7D,QAAQ,CAAC,QAAQ,CAAC,iBAAiB,KAAK,KAAK,CAAC,MAAM,CAAC,CACtD,CAAC;IACJ,CAAC;SAAM,IAAI,2BAA2B,CAAC,OAAO,CAAC,IAAI,mCAAmC,EAAE,EAAE,CAAC;QACzF,0BAA0B;QAC1B,OAAO,gBAAgB,CAAC,OAAO,EAAE,wBAAwB,EAAE,CAAC,KAAK,EAAE,EAAE,CACnE,QAAQ,CAAC,QAAQ,CAAC,yBAAyB,CAAC,KAAK,KAAK,CAAC,MAAM,CAAC,CAC/D,CAAC;IACJ,CAAC;SAAM,IAAI,2BAA2B,CAAC,OAAO,CAAC,EAAE,CAAC;QAChD,wBAAwB;QACxB,MAAM,mBAAmB,GAAG,gBAAgB,CAAC,OAAO,EAAE,uBAAuB,EAAE,GAAG,EAAE,CAClF,QAAQ,CAAC,IAAI,CAAC,CACf,CAAC;QACF,MAAM,iBAAiB,GAAG,gBAAgB,CAAC,OAAO,EAAE,qBAAqB,EAAE,GAAG,EAAE,CAC9E,QAAQ,CAAC,KAAK,CAAC,CAChB,CAAC;QACF,OAAO,GAAG,EAAE;YACV,mBAAmB,EAAE,CAAC;YACtB,iBAAiB,EAAE,CAAC;QACtB,CAAC,CAAC;IACJ,CAAC;SAAM,IAAI,uBAAuB,CAAC,OAAO,CAAC,EAAE,CAAC;QAC5C,eAAe;QACf,OAAO,gBAAgB,CAAC,QAAQ,EAAE,oBAAoB,EAAE,CAAC,KAAK,EAAE,EAAE,CAChE,QAAQ,CAAC,QAAQ,CAAC,qBAAqB,CAAC,KAAK,KAAK,CAAC,MAAM,CAAC,CAC3D,CAAC;IACJ,CAAC;SAAM,CAAC;QACN,OAAO,GAAG,EAAE,GAAE,CAAC,CAAC;IAClB,CAAC;AACH,CAAC","sourcesContent":["/**\n * Detect if the browser supports the standard fullscreen API on the given\n * element:\n * https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API\n */\nconst supportsFullscreenAPI = (element: HTMLMediaElement): boolean =>\n  'requestFullscreen' in element;\n\n/**\n * Detect if the browser supports the non-standard webkit fullscreen API on the\n * given element (looking at you, Safari).\n */\nconst supportsWebkitFullscreenAPI = (element: HTMLMediaElement): boolean =>\n  'webkitEnterFullScreen' in element;\n\n/**\n * Detect if the browser supports the non-standard ms fullscreen API on the\n * given element (looking at you, IE11).\n */\nconst supportsMsFullscreenAPI = (element: HTMLMediaElement): boolean =>\n  'msRequestFullscreen' in element;\n\n/**\n * Detect if the browser supports the `webkitFullscreenChange` event. This is\n * a non-standard event added to Safari on macOS by Apple:\n * https://developer.apple.com/documentation/webkitjs/document/1631998-onwebkitfullscreenchange\n */\nconst supportsWebkitFullscreenChangeEvent = (): boolean =>\n  supportsEvent('video', 'webkitfullscreenchange');\n\n/**\n * A helper that adds an event listener to an element. The key value-add over\n * the native addEventListener is that it returns a function that will remove\n * the event listener. This allows the setup and teardown logic for a listener\n * to be easily colocated.\n */\nfunction addEventListener(\n  element: Document | HTMLElement,\n  eventName: string,\n  listener: EventListenerOrEventListenerObject\n): () => any {\n  element.addEventListener(eventName, listener);\n  return () => element.removeEventListener(eventName, listener);\n}\n\n/**\n * Detect if the browser supports an event on a particular element type.\n */\nconst supportsEvent = (elementName: string, eventName: string): boolean => {\n  // Detect if the browser supports the event by attempting to add a handler\n  // attribute for that event to the provided element. If the event is supported\n  // then the browser will accept the attribute and report the type of the\n  // attribute as \"function\". See: https://stackoverflow.com/a/4562426/2747759\n  const element = document.createElement(elementName);\n  element.setAttribute('on' + eventName, 'return;');\n  return typeof element['on' + eventName] === 'function';\n};\n\n/**\n * Switches a video element into fullscreen.\n */\nexport async function requestFullscreen(element: HTMLMediaElement): Promise<void> {\n  if (supportsFullscreenAPI(element)) {\n    return element.requestFullscreen();\n  } else if (supportsWebkitFullscreenAPI(element)) {\n    // This API is synchronous so no need to return the result\n    element['webkitEnterFullScreen']?.();\n  } else if (supportsMsFullscreenAPI(element)) {\n    // This API is synchronous so no need to return the result\n    element['msRequestFullscreen']?.();\n  } else {\n    throw new Error('Fullscreen not supported');\n  }\n}\n\n/**\n * Switches a video element out of fullscreen.\n */\n\nexport async function exitFullscreen(element: HTMLMediaElement): Promise<void> {\n  if (supportsFullscreenAPI(element)) {\n    return document.exitFullscreen();\n  } else if (supportsWebkitFullscreenAPI(element)) {\n    // This API is synchronous so no need to return the result\n    element['webkitExitFullScreen']?.();\n  } else if (supportsMsFullscreenAPI(element)) {\n    // This API is synchronous so no need to return the result\n    document['msExitFullscreen']?.();\n  } else {\n    throw new Error('Fullscreen not supported');\n  }\n}\n\n/**\n * Listens for fullscreen change events on a video element. The provided\n * callback will be called with `true` when the video is switched into\n * fullscreen and `false` when the video is switched out of fullscreen.\n */\nexport function addFullscreenListener(\n  element: HTMLVideoElement,\n  callback: (isFullscreen: boolean) => void\n): () => any {\n  if (supportsFullscreenAPI(element)) {\n    // Used by browsers that support the official spec\n    return addEventListener(element, 'fullscreenchange', (event) =>\n      callback(document.fullscreenElement === event.target)\n    );\n  } else if (supportsWebkitFullscreenAPI(element) && supportsWebkitFullscreenChangeEvent()) {\n    // Used by Safari on macOS\n    return addEventListener(element, 'webkitfullscreenchange', (event) =>\n      callback(document['webkitFullscreenElement'] === event.target)\n    );\n  } else if (supportsWebkitFullscreenAPI(element)) {\n    // Used by Safari on iOS\n    const removeBeginListener = addEventListener(element, 'webkitbeginfullscreen', () =>\n      callback(true)\n    );\n    const removeEndListener = addEventListener(element, 'webkitendfullscreen', () =>\n      callback(false)\n    );\n    return () => {\n      removeBeginListener();\n      removeEndListener();\n    };\n  } else if (supportsMsFullscreenAPI(element)) {\n    // Used by IE11\n    return addEventListener(document, 'MSFullscreenChange', (event) =>\n      callback(document['msFullscreenElement'] === event.target)\n    );\n  } else {\n    return () => {};\n  }\n}\n"]}
\ No newline at end of file
diff --git a/build/Video.d.ts b/build/Video.d.ts
index d9b3a7b0e70ad74c41a6063675f51d18854bb8c0..cfa12dd7734ecd518c7708c4f9ea10ae12cae5f8 100644
--- a/build/Video.d.ts
+++ b/build/Video.d.ts
@@ -90,8 +90,8 @@ declare class Video extends React.Component<VideoProps, VideoState> implements P
     _nativeOnFullscreenUpdate: (event: {
         nativeEvent: VideoFullscreenUpdateEvent;
     }) => void;
-    _renderPoster: () => JSX.Element | null;
-    render(): JSX.Element;
+    _renderPoster: () => React.JSX.Element | null;
+    render(): React.JSX.Element;
 }
 export default Video;
 //# sourceMappingURL=Video.d.ts.map
\ No newline at end of file
diff --git a/build/Video.d.ts.map b/build/Video.d.ts.map
index 1af056dd1e8afecf8ebbf70991f395dedfd6a1ca..0baa107fa4391ecc3d947e36e648dc2b8c2abeb2 100644
--- a/build/Video.d.ts.map
+++ b/build/Video.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"Video.d.ts","sourceRoot":"","sources":["../src/Video.tsx"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"Video.d.ts","sourceRoot":"","sources":["../src/Video.tsx"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/build/Video.js b/build/Video.js
index 3e89cc049b4ea6d80acbe5dc6d777491e49c007b..21a553a355c9437de789f571b203cff5f699f40e 100644
--- a/build/Video.js
+++ b/build/Video.js
@@ -206,7 +206,7 @@ class Video extends React.Component {
     };
     _renderPoster = () => {
         const PosterComponent = this.props.PosterComponent ?? Image;
-        return this.props.usePoster && this.state.showPoster ? (<PosterComponent style={[_STYLES.poster, this.props.posterStyle]} source={this.props.posterSource}/>) : null;
+        return this.props.usePoster && this.state.showPoster ? (React.createElement(PosterComponent, { style: [_STYLES.poster, this.props.posterStyle], source: this.props.posterSource })) : null;
     };
     render() {
         const source = getNativeSourceFromSource(this.props.source) || undefined;
@@ -261,10 +261,9 @@ class Video extends React.Component {
             onReadyForDisplay: this._nativeOnReadyForDisplay,
             onFullscreenUpdate: this._nativeOnFullscreenUpdate,
         };
-        return (<View style={nativeProps.style} pointerEvents="box-none">
-        <ExponentVideo ref={this._nativeRef} {...nativeProps} style={nativeProps.videoStyle}/>
-        {this._renderPoster()}
-      </View>);
+        return (React.createElement(View, { style: nativeProps.style, pointerEvents: "box-none" },
+            React.createElement(ExponentVideo, { ref: this._nativeRef, ...nativeProps, style: nativeProps.videoStyle }),
+            this._renderPoster()));
     }
 }
 function omit(props, propNames) {
diff --git a/build/Video.js.map b/build/Video.js.map
index b7c92a3efa9fb4f2f82aef7402007b43b36bd526..ba22673b12a3035c3ad47944d9bfab59cc71f40b 100644
--- a/build/Video.js.map
+++ b/build/Video.js.map
@@ -1 +1 @@
-{"version":3,"file":"Video.js","sourceRoot":"","sources":["../src/Video.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,cAAc,EAAE,KAAK,EAAiB,UAAU,EAAE,IAAI,EAAE,MAAM,cAAc,CAAC;AAEtF,OAAO,EACL,0BAA0B,EAC1B,+CAA+C,EAC/C,yBAAyB,EACzB,iBAAiB,EAEjB,aAAa,GAMd,MAAM,MAAM,CAAC;AACd,OAAO,gBAAgB,MAAM,oBAAoB,CAAC;AAClD,OAAO,UAAU,MAAM,cAAc,CAAC;AACtC,OAAO,aAAa,MAAM,iBAAiB,CAAC;AAC5C,OAAO,EAML,UAAU,GAEX,MAAM,eAAe,CAAC;AAEvB,MAAM,OAAO,GAAG,UAAU,CAAC,MAAM,CAAC;IAChC,IAAI,EAAE;QACJ,QAAQ,EAAE,QAAQ;KACnB;IACD,MAAM,EAAE;QACN,QAAQ,EAAE,UAAU;QACpB,IAAI,EAAE,CAAC;QACP,GAAG,EAAE,CAAC;QACN,KAAK,EAAE,CAAC;QACR,MAAM,EAAE,CAAC;QACT,UAAU,EAAE,SAAS;KACtB;IACD,KAAK,EAAE;QACL,QAAQ,EAAE,UAAU;QACpB,IAAI,EAAE,CAAC;QACP,GAAG,EAAE,CAAC;QACN,KAAK,EAAE,CAAC;QACR,MAAM,EAAE,CAAC;KACV;CACF,CAAC,CAAC;AAEH,kGAAkG;AAClG,qEAAqE;AACrE,MAAM,yBAAyB,GAAG,gBAAgB,CAAC;AACnD,MAAM,oBAAoB,GAAG,gBAAgB,CAAC;AAE9C,MAAM,KAAM,SAAQ,KAAK,CAAC,SAAiC;IACzD,UAAU,GAAG,KAAK,CAAC,SAAS,EAAwD,CAAC;IACrF,uBAAuB,GAAgD,IAAI,CAAC;IAE5E,YAAY,KAAiB;QAC3B,KAAK,CAAC,KAAK,CAAC,CAAC;QACb,IAAI,CAAC,KAAK,GAAG;YACX,UAAU,EAAE,CAAC,CAAC,KAAK,CAAC,SAAS;SAC9B,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,cAAc,CAAC,WAA6B;QAC1C,MAAM,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;QAC5C,IAAI,CAAC,WAAW;YAAE,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;QAC5E,WAAW,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;IAC1C,CAAC;IAED,mBAAmB;IAEnB,gBAAgB,GAAG,CAAC,MAAwB,EAAE,EAAE;QAC9C,IACE,IAAI,CAAC,KAAK,CAAC,UAAU;YACrB,MAAM,CAAC,QAAQ;YACf,CAAC,MAAM,CAAC,SAAS,IAAI,MAAM,CAAC,cAAc,KAAK,CAAC,CAAC,EACjD;YACA,IAAI,CAAC,QAAQ,CAAC,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;SACtC;QAED,IAAI,IAAI,CAAC,KAAK,CAAC,sBAAsB,EAAE;YACrC,IAAI,CAAC,KAAK,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;SAC3C;QACD,IAAI,IAAI,CAAC,uBAAuB,EAAE;YAChC,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;SACtC;IACH,CAAC,CAAC;IAEF,qCAAqC,GAAG,KAAK,EAC3C,SAAqD,EAC1B,EAAE;QAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;QACtC,IAAI,CAAC,KAAK,EAAE;YACV,MAAM,IAAI,KAAK,CAAC,0EAA0E,CAAC,CAAC;SAC7F;QAED,MAAM,MAAM,GAAG,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAE,CAAC;QACxD,MAAM,MAAM,GAAqB,MAAM,SAAS,CAAC,MAAM,CAAC,CAAC;QACzD,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;QAC9B,OAAO,MAAM,CAAC;IAChB,CAAC,CAAC;IAEF,oBAAoB;IAEpB,cAAc,GAAG,KAAK,EAAE,KAAc,EAA6B,EAAE;QACnE,OAAO,IAAI,CAAC,qCAAqC,CAAC,CAAC,GAAW,EAAE,EAAE,CAChE,oBAAoB,CAAC,aAAa,CAAC,GAAG,EAAE,KAAK,CAAC,CAC/C,CAAC;IACJ,CAAC,CAAC;IAEF;;;;;OAKG;IACH,uBAAuB,GAAG,KAAK,IAA+B,EAAE;QAC9D,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;IACnC,CAAC,CAAC;IAEF;;;;OAIG;IACH,uBAAuB,GAAG,KAAK,IAA+B,EAAE;QAC9D,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC,CAAC;IAEF,0DAA0D;IAC1D,wEAAwE;IAExE;;OAEG;IACH,cAAc,GAAG,KAAK,IAA+B,EAAE;QACrD,OAAO,IAAI,CAAC,qCAAqC,CAAC,CAAC,GAAW,EAAE,EAAE,CAChE,UAAU,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAClC,CAAC;IACJ,CAAC,CAAC;IAEF;;OAEG;IACH,SAAS,GAAG,KAAK,EACf,MAAwB,EACxB,gBAAuC,EAAE,EACzC,gBAAyB,IAAI,EACF,EAAE;QAC7B,MAAM,EAAE,YAAY,EAAE,iBAAiB,EAAE,GACvC,MAAM,+CAA+C,CAAC,MAAM,EAAE,aAAa,EAAE,aAAa,CAAC,CAAC;QAC9F,OAAO,IAAI,CAAC,qCAAqC,CAAC,CAAC,GAAW,EAAE,EAAE,CAChE,UAAU,CAAC,YAAY,CAAC,GAAG,EAAE,YAAY,EAAE,iBAAiB,CAAC,CAC9D,CAAC;IACJ,CAAC,CAAC;IAEF;;;OAGG;IACH,WAAW,GAAG,KAAK,IAA+B,EAAE;QAClD,OAAO,IAAI,CAAC,qCAAqC,CAAC,CAAC,GAAW,EAAE,EAAE,CAChE,UAAU,CAAC,cAAc,CAAC,GAAG,CAAC,CAC/B,CAAC;IACJ,CAAC,CAAC;IAEF,oBAAoB;QAClB,wDAAwD;QACxD,IAAI,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE;YAC5B,gGAAgG;YAChG,4BAA4B;YAC5B,6EAA6E;YAC7E,oCAAoC;QACtC,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;OAGG;IACH,cAAc,GAAG,KAAK,EAAE,MAA6B,EAA6B,EAAE;QAClF,0BAA0B,CAAC,MAAM,CAAC,CAAC;QACnC,OAAO,IAAI,CAAC,qCAAqC,CAAC,CAAC,GAAW,EAAE,EAAE,CAChE,UAAU,CAAC,iBAAiB,CAAC,GAAG,EAAE,MAAM,CAAC,CAC1C,CAAC;IACJ,CAAC,CAAC;IAEF;;OAEG;IACH,WAAW,GAAG,KAAK,EAAE,SAAgC,EAAE,EAA6B,EAAE;QACpF,IAAI,MAAM,CAAC,cAAc,IAAI,MAAM,CAAC,cAAc,KAAK,CAAC,EAAE;YACxD,MAAM,IAAI,KAAK,CAAC,8CAA8C,CAAC,CAAC;SACjE;QAED,OAAO,IAAI,CAAC,qCAAqC,CAAC,CAAC,GAAW,EAAE,EAAE,CAChE,UAAU,CAAC,WAAW,CAAC,GAAG,EAAE;YAC1B,GAAG,MAAM;YACT,cAAc,EAAE,CAAC;YACjB,UAAU,EAAE,IAAI;SACjB,CAAC,CACH,CAAC;IACJ,CAAC,CAAC;IAEF;;;;;;;;;;;OAWG;IACH,yBAAyB,CAAC,sBAAmE;QAC3F,IAAI,CAAC,uBAAuB,GAAG,sBAAsB,CAAC;QACtD,IAAI,CAAC,cAAc,EAAE,CAAC;IACxB,CAAC;IAED,mEAAmE;IACnE,SAAS,CAAmC;IAC5C,qBAAqB,CAGU;IAC/B,UAAU,CAAmC;IAC7C,SAAS,CAAmC;IAC5C,gBAAgB,CAGe;IAC/B,YAAY,CAImB;IAC/B,cAAc,CAAoE;IAClF,eAAe,CAAmD;IAClE,iBAAiB,CAAqD;IACtE,8BAA8B,CAEC;IAE/B,oBAAoB;IAEpB,6BAA6B,GAAG,CAAC,KAAwC,EAAE,EAAE;QAC3E,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;IAC3C,CAAC,CAAC;IAEF,gDAAgD;IAChD,kBAAkB,GAAG,GAAG,EAAE;QACxB,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;YAC1B,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;SAC1B;IACH,CAAC,CAAC;IAEF,aAAa,GAAG,CAAC,KAAwC,EAAE,EAAE;QAC3D,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;YACrB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;SACtC;QACD,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;IAC3C,CAAC,CAAC;IAEF,cAAc,GAAG,CAAC,KAAyC,EAAE,EAAE;QAC7D,MAAM,KAAK,GAAW,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC;QAC9C,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;YACtB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SAC3B;QACD,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC,CAAC;IAClD,CAAC,CAAC;IAEF,wBAAwB,GAAG,CAAC,KAAiD,EAAE,EAAE;QAC/E,IAAI,IAAI,CAAC,KAAK,CAAC,iBAAiB,EAAE;YAChC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;SACjD;IACH,CAAC,CAAC;IAEF,yBAAyB,GAAG,CAAC,KAAkD,EAAE,EAAE;QACjF,IAAI,IAAI,CAAC,KAAK,CAAC,kBAAkB,EAAE;YACjC,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;SAClD;IACH,CAAC,CAAC;IAEF,aAAa,GAAG,GAAG,EAAE;QACnB,MAAM,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,IAAI,KAAK,CAAC;QAE5D,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CACrD,CAAC,eAAe,CACd,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAChD,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,YAAa,CAAC,EACjC,CACH,CAAC,CAAC,CAAC,IAAI,CAAC;IACX,CAAC,CAAC;IAEF,MAAM;QACJ,MAAM,MAAM,GAAG,yBAAyB,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,SAAS,CAAC;QAEzE,IAAI,gBAAgB,GAAG,yBAAyB,CAAC,SAAS,CAAC;QAC3D,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;YACzB,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC;YACzC,IAAI,UAAU,KAAK,UAAU,CAAC,OAAO,EAAE;gBACrC,gBAAgB,GAAG,yBAAyB,CAAC,WAAW,CAAC;aAC1D;iBAAM,IAAI,UAAU,KAAK,UAAU,CAAC,OAAO,EAAE;gBAC5C,gBAAgB,GAAG,yBAAyB,CAAC,cAAc,CAAC;aAC7D;iBAAM,IAAI,UAAU,KAAK,UAAU,CAAC,KAAK,EAAE;gBAC1C,gBAAgB,GAAG,yBAAyB,CAAC,eAAe,CAAC;aAC9D;SACF;QAED,kCAAkC;QAClC,MAAM,MAAM,GAA0B,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;QAC/D;YACE,8BAA8B;YAC9B,gBAAgB;YAChB,YAAY;YACZ,MAAM;YACN,oBAAoB;YACpB,QAAQ;YACR,SAAS;YACT,WAAW;SACZ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YACjB,IAAI,IAAI,IAAI,IAAI,CAAC,KAAK,EAAE;gBACtB,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;aACjC;QACH,CAAC,CAAC,CAAC;QAEH,gCAAgC;QAChC,MAAM,WAAW,GAAqB;YACpC,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;gBAClB,QAAQ;gBACR,wBAAwB;gBACxB,WAAW;gBACX,cAAc;gBACd,aAAa;gBACb,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;aACvB,CAAC;YACF,KAAK,EAAE,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC;YACvC,UAAU,EAAE,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC;YAClD,MAAM;YACN,UAAU,EAAE,gBAAgB;YAC5B,MAAM;YACN,cAAc,EAAE,IAAI,CAAC,6BAA6B;YAClD,WAAW,EAAE,IAAI,CAAC,kBAAkB;YACpC,MAAM,EAAE,IAAI,CAAC,aAAa;YAC1B,OAAO,EAAE,IAAI,CAAC,cAAc;YAC5B,iBAAiB,EAAE,IAAI,CAAC,wBAAwB;YAChD,kBAAkB,EAAE,IAAI,CAAC,yBAAyB;SACnD,CAAC;QAEF,OAAO,CACL,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,aAAa,CAAC,UAAU,CACtD;QAAA,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,IAAI,WAAW,CAAC,CAAC,KAAK,CAAC,CAAC,WAAW,CAAC,UAAU,CAAC,EACpF;QAAA,CAAC,IAAI,CAAC,aAAa,EAAE,CACvB;MAAA,EAAE,IAAI,CAAC,CACR,CAAC;IACJ,CAAC;CACF;AAED,SAAS,IAAI,CAAC,KAA0B,EAAE,SAAmB;IAC3D,MAAM,MAAM,GAAG,EAAE,GAAG,KAAK,EAAE,CAAC;IAC5B,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE;QAChC,OAAO,MAAM,CAAC,QAAQ,CAAC,CAAC;KACzB;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;AAE9C,0FAA0F;AAC1F,eAAe,KAAK,CAAC","sourcesContent":["import * as React from 'react';\nimport { findNodeHandle, Image, NativeMethods, StyleSheet, View } from 'react-native';\n\nimport {\n  assertStatusValuesInBounds,\n  getNativeSourceAndFullInitialStatusForLoadAsync,\n  getNativeSourceFromSource,\n  getUnloadedStatus,\n  Playback,\n  PlaybackMixin,\n  AVPlaybackSource,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  AVPlaybackTolerance,\n  PitchCorrectionQuality,\n} from './AV';\nimport ExpoVideoManager from './ExpoVideoManager';\nimport ExponentAV from './ExponentAV';\nimport ExponentVideo from './ExponentVideo';\nimport {\n  ExponentVideoComponent,\n  VideoFullscreenUpdateEvent,\n  VideoNativeProps,\n  VideoProps,\n  VideoReadyForDisplayEvent,\n  ResizeMode,\n  VideoState,\n} from './Video.types';\n\nconst _STYLES = StyleSheet.create({\n  base: {\n    overflow: 'hidden',\n  },\n  poster: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    resizeMode: 'contain',\n  },\n  video: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n  },\n});\n\n// On a real device UIManager should be present, however when running offline tests with jest-expo\n// we have to use the provided native module mock to access constants\nconst ExpoVideoManagerConstants = ExpoVideoManager;\nconst ExpoVideoViewManager = ExpoVideoManager;\n\nclass Video extends React.Component<VideoProps, VideoState> implements Playback {\n  _nativeRef = React.createRef<InstanceType<ExponentVideoComponent> & NativeMethods>();\n  _onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null;\n\n  constructor(props: VideoProps) {\n    super(props);\n    this.state = {\n      showPoster: !!props.usePoster,\n    };\n  }\n\n  /**\n   * @hidden\n   */\n  setNativeProps(nativeProps: VideoNativeProps) {\n    const nativeVideo = this._nativeRef.current;\n    if (!nativeVideo) throw new Error(`native video reference is not defined.`);\n    nativeVideo.setNativeProps(nativeProps);\n  }\n\n  // Internal methods\n\n  _handleNewStatus = (status: AVPlaybackStatus) => {\n    if (\n      this.state.showPoster &&\n      status.isLoaded &&\n      (status.isPlaying || status.positionMillis !== 0)\n    ) {\n      this.setState({ showPoster: false });\n    }\n\n    if (this.props.onPlaybackStatusUpdate) {\n      this.props.onPlaybackStatusUpdate(status);\n    }\n    if (this._onPlaybackStatusUpdate) {\n      this._onPlaybackStatusUpdate(status);\n    }\n  };\n\n  _performOperationAndHandleStatusAsync = async (\n    operation: (tag: number) => Promise<AVPlaybackStatus>\n  ): Promise<AVPlaybackStatus> => {\n    const video = this._nativeRef.current;\n    if (!video) {\n      throw new Error(`Cannot complete operation because the Video component has not yet loaded`);\n    }\n\n    const handle = findNodeHandle(this._nativeRef.current)!;\n    const status: AVPlaybackStatus = await operation(handle);\n    this._handleNewStatus(status);\n    return status;\n  };\n\n  // Fullscreening API\n\n  _setFullscreen = async (value: boolean): Promise<AVPlaybackStatus> => {\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExpoVideoViewManager.setFullscreen(tag, value)\n    );\n  };\n\n  /**\n   * This presents a fullscreen view of your video component on top of your app's UI. Note that even if `useNativeControls` is set to `false`,\n   * native controls will be visible in fullscreen mode.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the video once the fullscreen player has finished presenting,\n   * or rejects if there was an error, or if this was called on an Android device.\n   */\n  presentFullscreenPlayer = async (): Promise<AVPlaybackStatus> => {\n    return this._setFullscreen(true);\n  };\n\n  /**\n   * This dismisses the fullscreen video view.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the video once the fullscreen player has finished dismissing,\n   * or rejects if there was an error, or if this was called on an Android device.\n   */\n  dismissFullscreenPlayer = async (): Promise<AVPlaybackStatus> => {\n    return this._setFullscreen(false);\n  };\n\n  // ### Unified playback API ### (consistent with Audio.js)\n  // All calls automatically call onPlaybackStatusUpdate as a side effect.\n\n  /**\n   * @hidden\n   */\n  getStatusAsync = async (): Promise<AVPlaybackStatus> => {\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.getStatusForVideo(tag)\n    );\n  };\n\n  /**\n   * @hidden\n   */\n  loadAsync = async (\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet = {},\n    downloadFirst: boolean = true\n  ): Promise<AVPlaybackStatus> => {\n    const { nativeSource, fullInitialStatus } =\n      await getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst);\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.loadForVideo(tag, nativeSource, fullInitialStatus)\n    );\n  };\n\n  /**\n   * Equivalent to setting URI to `null`.\n   * @hidden\n   */\n  unloadAsync = async (): Promise<AVPlaybackStatus> => {\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.unloadForVideo(tag)\n    );\n  };\n\n  componentWillUnmount() {\n    // Auto unload video to perform necessary cleanup safely\n    this.unloadAsync().catch(() => {\n      // Ignored rejection. Sometimes the unloadAsync code is executed when video is already unloaded.\n      // In such cases, it throws:\n      // \"[Unhandled promise rejection: Error: Invalid view returned from registry,\n      //  expecting EXVideo, got: (null)]\"\n    });\n  }\n\n  /**\n   * Set status API, only available while `isLoaded = true`.\n   * @hidden\n   */\n  setStatusAsync = async (status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus> => {\n    assertStatusValuesInBounds(status);\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.setStatusForVideo(tag, status)\n    );\n  };\n\n  /**\n   * @hidden\n   */\n  replayAsync = async (status: AVPlaybackStatusToSet = {}): Promise<AVPlaybackStatus> => {\n    if (status.positionMillis && status.positionMillis !== 0) {\n      throw new Error('Requested position after replay has to be 0.');\n    }\n\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.replayVideo(tag, {\n        ...status,\n        positionMillis: 0,\n        shouldPlay: true,\n      })\n    );\n  };\n\n  /**\n   * Sets a function to be called regularly with the `AVPlaybackStatus` of the playback object.\n   *\n   * `onPlaybackStatusUpdate` will be called whenever a call to the API for this playback object completes\n   * (such as `setStatusAsync()`, `getStatusAsync()`, or `unloadAsync()`), nd will also be called at regular intervals\n   * while the media is in the loaded state.\n   *\n   * Set `progressUpdateIntervalMillis` via `setStatusAsync()` or `setProgressUpdateIntervalAsync()` to modify\n   * the interval with which `onPlaybackStatusUpdate` is called while loaded.\n   *\n   * @param onPlaybackStatusUpdate A function taking a single parameter `AVPlaybackStatus`.\n   */\n  setOnPlaybackStatusUpdate(onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null) {\n    this._onPlaybackStatusUpdate = onPlaybackStatusUpdate;\n    this.getStatusAsync();\n  }\n\n  // Methods of the Playback interface that are set via PlaybackMixin\n  playAsync!: () => Promise<AVPlaybackStatus>;\n  playFromPositionAsync!: (\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ) => Promise<AVPlaybackStatus>;\n  pauseAsync!: () => Promise<AVPlaybackStatus>;\n  stopAsync!: () => Promise<AVPlaybackStatus>;\n  setPositionAsync!: (\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ) => Promise<AVPlaybackStatus>;\n  setRateAsync!: (\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ) => Promise<AVPlaybackStatus>;\n  setVolumeAsync!: (volume: number, audioPan?: number) => Promise<AVPlaybackStatus>;\n  setIsMutedAsync!: (isMuted: boolean) => Promise<AVPlaybackStatus>;\n  setIsLoopingAsync!: (isLooping: boolean) => Promise<AVPlaybackStatus>;\n  setProgressUpdateIntervalAsync!: (\n    progressUpdateIntervalMillis: number\n  ) => Promise<AVPlaybackStatus>;\n\n  // Callback wrappers\n\n  _nativeOnPlaybackStatusUpdate = (event: { nativeEvent: AVPlaybackStatus }) => {\n    this._handleNewStatus(event.nativeEvent);\n  };\n\n  // TODO make sure we are passing the right stuff\n  _nativeOnLoadStart = () => {\n    if (this.props.onLoadStart) {\n      this.props.onLoadStart();\n    }\n  };\n\n  _nativeOnLoad = (event: { nativeEvent: AVPlaybackStatus }) => {\n    if (this.props.onLoad) {\n      this.props.onLoad(event.nativeEvent);\n    }\n    this._handleNewStatus(event.nativeEvent);\n  };\n\n  _nativeOnError = (event: { nativeEvent: { error: string } }) => {\n    const error: string = event.nativeEvent.error;\n    if (this.props.onError) {\n      this.props.onError(error);\n    }\n    this._handleNewStatus(getUnloadedStatus(error));\n  };\n\n  _nativeOnReadyForDisplay = (event: { nativeEvent: VideoReadyForDisplayEvent }) => {\n    if (this.props.onReadyForDisplay) {\n      this.props.onReadyForDisplay(event.nativeEvent);\n    }\n  };\n\n  _nativeOnFullscreenUpdate = (event: { nativeEvent: VideoFullscreenUpdateEvent }) => {\n    if (this.props.onFullscreenUpdate) {\n      this.props.onFullscreenUpdate(event.nativeEvent);\n    }\n  };\n\n  _renderPoster = () => {\n    const PosterComponent = this.props.PosterComponent ?? Image;\n\n    return this.props.usePoster && this.state.showPoster ? (\n      <PosterComponent\n        style={[_STYLES.poster, this.props.posterStyle]}\n        source={this.props.posterSource!}\n      />\n    ) : null;\n  };\n\n  render() {\n    const source = getNativeSourceFromSource(this.props.source) || undefined;\n\n    let nativeResizeMode = ExpoVideoManagerConstants.ScaleNone;\n    if (this.props.resizeMode) {\n      const resizeMode = this.props.resizeMode;\n      if (resizeMode === ResizeMode.STRETCH) {\n        nativeResizeMode = ExpoVideoManagerConstants.ScaleToFill;\n      } else if (resizeMode === ResizeMode.CONTAIN) {\n        nativeResizeMode = ExpoVideoManagerConstants.ScaleAspectFit;\n      } else if (resizeMode === ResizeMode.COVER) {\n        nativeResizeMode = ExpoVideoManagerConstants.ScaleAspectFill;\n      }\n    }\n\n    // Set status via individual props\n    const status: AVPlaybackStatusToSet = { ...this.props.status };\n    [\n      'progressUpdateIntervalMillis',\n      'positionMillis',\n      'shouldPlay',\n      'rate',\n      'shouldCorrectPitch',\n      'volume',\n      'isMuted',\n      'isLooping',\n    ].forEach((prop) => {\n      if (prop in this.props) {\n        status[prop] = this.props[prop];\n      }\n    });\n\n    // Replace selected native props\n    const nativeProps: VideoNativeProps = {\n      ...omit(this.props, [\n        'source',\n        'onPlaybackStatusUpdate',\n        'usePoster',\n        'posterSource',\n        'posterStyle',\n        ...Object.keys(status),\n      ]),\n      style: [_STYLES.base, this.props.style],\n      videoStyle: [_STYLES.video, this.props.videoStyle],\n      source,\n      resizeMode: nativeResizeMode,\n      status,\n      onStatusUpdate: this._nativeOnPlaybackStatusUpdate,\n      onLoadStart: this._nativeOnLoadStart,\n      onLoad: this._nativeOnLoad,\n      onError: this._nativeOnError,\n      onReadyForDisplay: this._nativeOnReadyForDisplay,\n      onFullscreenUpdate: this._nativeOnFullscreenUpdate,\n    };\n\n    return (\n      <View style={nativeProps.style} pointerEvents=\"box-none\">\n        <ExponentVideo ref={this._nativeRef} {...nativeProps} style={nativeProps.videoStyle} />\n        {this._renderPoster()}\n      </View>\n    );\n  }\n}\n\nfunction omit(props: Record<string, any>, propNames: string[]) {\n  const copied = { ...props };\n  for (const propName of propNames) {\n    delete copied[propName];\n  }\n  return copied;\n}\n\nObject.assign(Video.prototype, PlaybackMixin);\n\n// note(simek): TypeDoc cannot resolve correctly name of inline and default exported class\nexport default Video;\n"]}
\ No newline at end of file
+{"version":3,"file":"Video.js","sourceRoot":"","sources":["../src/Video.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { findNodeHandle, Image, NativeMethods, StyleSheet, View } from 'react-native';\n\nimport {\n  assertStatusValuesInBounds,\n  getNativeSourceAndFullInitialStatusForLoadAsync,\n  getNativeSourceFromSource,\n  getUnloadedStatus,\n  Playback,\n  PlaybackMixin,\n  AVPlaybackSource,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  AVPlaybackTolerance,\n  PitchCorrectionQuality,\n} from './AV';\nimport ExpoVideoManager from './ExpoVideoManager';\nimport ExponentAV from './ExponentAV';\nimport ExponentVideo from './ExponentVideo';\nimport {\n  ExponentVideoComponent,\n  VideoFullscreenUpdateEvent,\n  VideoNativeProps,\n  VideoProps,\n  VideoReadyForDisplayEvent,\n  ResizeMode,\n  VideoState,\n} from './Video.types';\n\nconst _STYLES = StyleSheet.create({\n  base: {\n    overflow: 'hidden',\n  },\n  poster: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    resizeMode: 'contain',\n  },\n  video: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n  },\n});\n\n// On a real device UIManager should be present, however when running offline tests with jest-expo\n// we have to use the provided native module mock to access constants\nconst ExpoVideoManagerConstants = ExpoVideoManager;\nconst ExpoVideoViewManager = ExpoVideoManager;\n\nclass Video extends React.Component<VideoProps, VideoState> implements Playback {\n  _nativeRef = React.createRef<InstanceType<ExponentVideoComponent> & NativeMethods>();\n  _onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null;\n\n  constructor(props: VideoProps) {\n    super(props);\n    this.state = {\n      showPoster: !!props.usePoster,\n    };\n  }\n\n  /**\n   * @hidden\n   */\n  setNativeProps(nativeProps: VideoNativeProps) {\n    const nativeVideo = this._nativeRef.current;\n    if (!nativeVideo) throw new Error(`native video reference is not defined.`);\n    nativeVideo.setNativeProps(nativeProps);\n  }\n\n  // Internal methods\n\n  _handleNewStatus = (status: AVPlaybackStatus) => {\n    if (\n      this.state.showPoster &&\n      status.isLoaded &&\n      (status.isPlaying || status.positionMillis !== 0)\n    ) {\n      this.setState({ showPoster: false });\n    }\n\n    if (this.props.onPlaybackStatusUpdate) {\n      this.props.onPlaybackStatusUpdate(status);\n    }\n    if (this._onPlaybackStatusUpdate) {\n      this._onPlaybackStatusUpdate(status);\n    }\n  };\n\n  _performOperationAndHandleStatusAsync = async (\n    operation: (tag: number) => Promise<AVPlaybackStatus>\n  ): Promise<AVPlaybackStatus> => {\n    const video = this._nativeRef.current;\n    if (!video) {\n      throw new Error(`Cannot complete operation because the Video component has not yet loaded`);\n    }\n\n    const handle = findNodeHandle(this._nativeRef.current)!;\n    const status: AVPlaybackStatus = await operation(handle);\n    this._handleNewStatus(status);\n    return status;\n  };\n\n  // Fullscreening API\n\n  _setFullscreen = async (value: boolean): Promise<AVPlaybackStatus> => {\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExpoVideoViewManager.setFullscreen(tag, value)\n    );\n  };\n\n  /**\n   * This presents a fullscreen view of your video component on top of your app's UI. Note that even if `useNativeControls` is set to `false`,\n   * native controls will be visible in fullscreen mode.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the video once the fullscreen player has finished presenting,\n   * or rejects if there was an error, or if this was called on an Android device.\n   */\n  presentFullscreenPlayer = async (): Promise<AVPlaybackStatus> => {\n    return this._setFullscreen(true);\n  };\n\n  /**\n   * This dismisses the fullscreen video view.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the video once the fullscreen player has finished dismissing,\n   * or rejects if there was an error, or if this was called on an Android device.\n   */\n  dismissFullscreenPlayer = async (): Promise<AVPlaybackStatus> => {\n    return this._setFullscreen(false);\n  };\n\n  // ### Unified playback API ### (consistent with Audio.js)\n  // All calls automatically call onPlaybackStatusUpdate as a side effect.\n\n  /**\n   * @hidden\n   */\n  getStatusAsync = async (): Promise<AVPlaybackStatus> => {\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.getStatusForVideo(tag)\n    );\n  };\n\n  /**\n   * @hidden\n   */\n  loadAsync = async (\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet = {},\n    downloadFirst: boolean = true\n  ): Promise<AVPlaybackStatus> => {\n    const { nativeSource, fullInitialStatus } =\n      await getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst);\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.loadForVideo(tag, nativeSource, fullInitialStatus)\n    );\n  };\n\n  /**\n   * Equivalent to setting URI to `null`.\n   * @hidden\n   */\n  unloadAsync = async (): Promise<AVPlaybackStatus> => {\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.unloadForVideo(tag)\n    );\n  };\n\n  componentWillUnmount() {\n    // Auto unload video to perform necessary cleanup safely\n    this.unloadAsync().catch(() => {\n      // Ignored rejection. Sometimes the unloadAsync code is executed when video is already unloaded.\n      // In such cases, it throws:\n      // \"[Unhandled promise rejection: Error: Invalid view returned from registry,\n      //  expecting EXVideo, got: (null)]\"\n    });\n  }\n\n  /**\n   * Set status API, only available while `isLoaded = true`.\n   * @hidden\n   */\n  setStatusAsync = async (status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus> => {\n    assertStatusValuesInBounds(status);\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.setStatusForVideo(tag, status)\n    );\n  };\n\n  /**\n   * @hidden\n   */\n  replayAsync = async (status: AVPlaybackStatusToSet = {}): Promise<AVPlaybackStatus> => {\n    if (status.positionMillis && status.positionMillis !== 0) {\n      throw new Error('Requested position after replay has to be 0.');\n    }\n\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.replayVideo(tag, {\n        ...status,\n        positionMillis: 0,\n        shouldPlay: true,\n      })\n    );\n  };\n\n  /**\n   * Sets a function to be called regularly with the `AVPlaybackStatus` of the playback object.\n   *\n   * `onPlaybackStatusUpdate` will be called whenever a call to the API for this playback object completes\n   * (such as `setStatusAsync()`, `getStatusAsync()`, or `unloadAsync()`), nd will also be called at regular intervals\n   * while the media is in the loaded state.\n   *\n   * Set `progressUpdateIntervalMillis` via `setStatusAsync()` or `setProgressUpdateIntervalAsync()` to modify\n   * the interval with which `onPlaybackStatusUpdate` is called while loaded.\n   *\n   * @param onPlaybackStatusUpdate A function taking a single parameter `AVPlaybackStatus`.\n   */\n  setOnPlaybackStatusUpdate(onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null) {\n    this._onPlaybackStatusUpdate = onPlaybackStatusUpdate;\n    this.getStatusAsync();\n  }\n\n  // Methods of the Playback interface that are set via PlaybackMixin\n  playAsync!: () => Promise<AVPlaybackStatus>;\n  playFromPositionAsync!: (\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ) => Promise<AVPlaybackStatus>;\n  pauseAsync!: () => Promise<AVPlaybackStatus>;\n  stopAsync!: () => Promise<AVPlaybackStatus>;\n  setPositionAsync!: (\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ) => Promise<AVPlaybackStatus>;\n  setRateAsync!: (\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ) => Promise<AVPlaybackStatus>;\n  setVolumeAsync!: (volume: number, audioPan?: number) => Promise<AVPlaybackStatus>;\n  setIsMutedAsync!: (isMuted: boolean) => Promise<AVPlaybackStatus>;\n  setIsLoopingAsync!: (isLooping: boolean) => Promise<AVPlaybackStatus>;\n  setProgressUpdateIntervalAsync!: (\n    progressUpdateIntervalMillis: number\n  ) => Promise<AVPlaybackStatus>;\n\n  // Callback wrappers\n\n  _nativeOnPlaybackStatusUpdate = (event: { nativeEvent: AVPlaybackStatus }) => {\n    this._handleNewStatus(event.nativeEvent);\n  };\n\n  // TODO make sure we are passing the right stuff\n  _nativeOnLoadStart = () => {\n    if (this.props.onLoadStart) {\n      this.props.onLoadStart();\n    }\n  };\n\n  _nativeOnLoad = (event: { nativeEvent: AVPlaybackStatus }) => {\n    if (this.props.onLoad) {\n      this.props.onLoad(event.nativeEvent);\n    }\n    this._handleNewStatus(event.nativeEvent);\n  };\n\n  _nativeOnError = (event: { nativeEvent: { error: string } }) => {\n    const error: string = event.nativeEvent.error;\n    if (this.props.onError) {\n      this.props.onError(error);\n    }\n    this._handleNewStatus(getUnloadedStatus(error));\n  };\n\n  _nativeOnReadyForDisplay = (event: { nativeEvent: VideoReadyForDisplayEvent }) => {\n    if (this.props.onReadyForDisplay) {\n      this.props.onReadyForDisplay(event.nativeEvent);\n    }\n  };\n\n  _nativeOnFullscreenUpdate = (event: { nativeEvent: VideoFullscreenUpdateEvent }) => {\n    if (this.props.onFullscreenUpdate) {\n      this.props.onFullscreenUpdate(event.nativeEvent);\n    }\n  };\n\n  _renderPoster = () => {\n    const PosterComponent = this.props.PosterComponent ?? Image;\n\n    return this.props.usePoster && this.state.showPoster ? (\n      <PosterComponent\n        style={[_STYLES.poster, this.props.posterStyle]}\n        source={this.props.posterSource!}\n      />\n    ) : null;\n  };\n\n  render() {\n    const source = getNativeSourceFromSource(this.props.source) || undefined;\n\n    let nativeResizeMode = ExpoVideoManagerConstants.ScaleNone;\n    if (this.props.resizeMode) {\n      const resizeMode = this.props.resizeMode;\n      if (resizeMode === ResizeMode.STRETCH) {\n        nativeResizeMode = ExpoVideoManagerConstants.ScaleToFill;\n      } else if (resizeMode === ResizeMode.CONTAIN) {\n        nativeResizeMode = ExpoVideoManagerConstants.ScaleAspectFit;\n      } else if (resizeMode === ResizeMode.COVER) {\n        nativeResizeMode = ExpoVideoManagerConstants.ScaleAspectFill;\n      }\n    }\n\n    // Set status via individual props\n    const status: AVPlaybackStatusToSet = { ...this.props.status };\n    [\n      'progressUpdateIntervalMillis',\n      'positionMillis',\n      'shouldPlay',\n      'rate',\n      'shouldCorrectPitch',\n      'volume',\n      'isMuted',\n      'isLooping',\n    ].forEach((prop) => {\n      if (prop in this.props) {\n        status[prop] = this.props[prop];\n      }\n    });\n\n    // Replace selected native props\n    const nativeProps: VideoNativeProps = {\n      ...omit(this.props, [\n        'source',\n        'onPlaybackStatusUpdate',\n        'usePoster',\n        'posterSource',\n        'posterStyle',\n        ...Object.keys(status),\n      ]),\n      style: [_STYLES.base, this.props.style],\n      videoStyle: [_STYLES.video, this.props.videoStyle],\n      source,\n      resizeMode: nativeResizeMode,\n      status,\n      onStatusUpdate: this._nativeOnPlaybackStatusUpdate,\n      onLoadStart: this._nativeOnLoadStart,\n      onLoad: this._nativeOnLoad,\n      onError: this._nativeOnError,\n      onReadyForDisplay: this._nativeOnReadyForDisplay,\n      onFullscreenUpdate: this._nativeOnFullscreenUpdate,\n    };\n\n    return (\n      <View style={nativeProps.style} pointerEvents=\"box-none\">\n        <ExponentVideo ref={this._nativeRef} {...nativeProps} style={nativeProps.videoStyle} />\n        {this._renderPoster()}\n      </View>\n    );\n  }\n}\n\nfunction omit(props: Record<string, any>, propNames: string[]) {\n  const copied = { ...props };\n  for (const propName of propNames) {\n    delete copied[propName];\n  }\n  return copied;\n}\n\nObject.assign(Video.prototype, PlaybackMixin);\n\n// note(simek): TypeDoc cannot resolve correctly name of inline and default exported class\nexport default Video;\n"]}
\ No newline at end of file
diff --git a/src/ExponentAV.web.ts b/src/ExponentAV.web.ts
index 4a8879595cef1d9a2f03a0908582224ded0959b2..eaa79872e85cbb5f49e04ff10e122f4e1161a49d 100644
--- a/src/ExponentAV.web.ts
+++ b/src/ExponentAV.web.ts
@@ -113,7 +113,7 @@ async function setStatusForMedia(
   // }
   if (status.shouldPlay !== undefined) {
     if (status.shouldPlay) {
-      await media.play();
+      await media.play().catch(console.warn);
     } else {
       await media.pause();
     }
diff --git a/src/ExponentVideo.web.tsx b/src/ExponentVideo.web.tsx
index d750b6752f70fb01e11a858e902f58aa05790dc1..14bdb7ab69107bf4ef6bf5ecdeeb698822fccfd6 100644
--- a/src/ExponentVideo.web.tsx
+++ b/src/ExponentVideo.web.tsx
@@ -1,6 +1,7 @@
 import * as React from 'react';
 import { ViewProps } from 'react-native';
 import createElement from 'react-native-web/dist/exports/createElement';
+import dashjs from 'dashjs';
 
 import { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV';
 import ExponentAV from './ExponentAV';
@@ -40,8 +41,13 @@ const Video: any = React.forwardRef<HTMLVideoElement, ExponentVideoProps>((props
   createElement('video', { ...props, ref })
 );
 
+const Source: any = React.forwardRef<HTMLSourceElement, { src: string }>((props, ref) =>
+  createElement('source', { ...props, ref })
+);
+
 export default class ExponentVideo extends React.Component<ExponentVideoProps> {
   _video?: HTMLVideoElement;
+  _dash?: dashjs.MediaPlayerClass;
   _removeFullscreenListener?: () => any;
 
   componentWillUnmount() {
@@ -125,6 +131,18 @@ export default class ExponentVideo extends React.Component<ExponentVideoProps> {
     this._removeFullscreenListener?.();
     if (ref) {
       this._video = ref;
+      const uri = this.getURI();
+      if (uri?.endsWith('.mpd')) {
+        try {
+          const dash = dashjs.MediaPlayer().create();
+          dash.initialize(this._video, uri, this.props.status?.shouldPlay || false);
+          dash.attachView(this._video);
+
+          this._dash = dash;
+        } catch (e) {
+          console.error(e);
+        }
+      }
       this._removeFullscreenListener = addFullscreenListener(this._video, this.onFullscreenChange);
       this.onStatusUpdate();
     } else {
@@ -132,6 +150,22 @@ export default class ExponentVideo extends React.Component<ExponentVideoProps> {
     }
   };
 
+  getURI(): string | undefined {
+    let uri = this.props.source?.uri;
+    if (!uri) {
+      return undefined;
+    }
+
+    if (uri.endsWith('.mpd')) {
+      const isIOS = /AppleWebKit/.test(navigator.userAgent) && /iPad|iPhone|iPod/.test(navigator.userAgent);
+      if (isIOS) {
+        uri = uri.replace('.mpd', '.m3u8');
+      }
+    }
+
+    return uri;
+  }
+
   render() {
     const { source, status = {}, resizeMode: objectFit, useNativeControls, style } = this.props;
 
@@ -140,6 +174,9 @@ export default class ExponentVideo extends React.Component<ExponentVideoProps> {
       objectFit,
       overflow: 'hidden',
     };
+
+    const uri = this.getURI();
+
     return (
       <Video
         ref={this.onRef}
@@ -152,14 +189,15 @@ export default class ExponentVideo extends React.Component<ExponentVideoProps> {
         onLoadedMetadata={this.onLoadedMetadata}
         onCanPlay={this.onCanPlay}
         onStalled={this.onStalled}
-        src={source?.uri || undefined}
+        src={uri}
         muted={status.isMuted}
         loop={status.isLooping}
         autoPlay={status.shouldPlay}
         controls={useNativeControls}
         style={[style, customStyle]}
         playsInline
-      />
+      >
+	  </Video>
     );
   }
 }
